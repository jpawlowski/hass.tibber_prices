{"searchDocs":[{"title":"Coding Guidelines","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/coding-guidelines","content":"","keywords":"","version":"Next ğŸš§"},{"title":"Code Styleâ€‹","type":1,"pageTitle":"Coding Guidelines","url":"/hass.tibber_prices/developer/coding-guidelines#code-style","content":" Formatter/Linter: Ruff (replaces Black, Flake8, isort)Max line length: 120 charactersMax complexity: 25 (McCabe)Target: Python 3.13  Run before committing:  ./scripts/lint # Auto-fix issues ./scripts/release/hassfest # Validate integration structure   ","version":"Next ğŸš§","tagName":"h2"},{"title":"Naming Conventionsâ€‹","type":1,"pageTitle":"Coding Guidelines","url":"/hass.tibber_prices/developer/coding-guidelines#naming-conventions","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Class Namesâ€‹","type":1,"pageTitle":"Coding Guidelines","url":"/hass.tibber_prices/developer/coding-guidelines#class-names","content":" All public classes MUST use the integration name as prefix.  This is a Home Assistant standard to avoid naming conflicts between integrations.  # âœ… CORRECT class TibberPricesApiClient: class TibberPricesDataUpdateCoordinator: class TibberPricesSensor: # âŒ WRONG - Missing prefix class ApiClient: class DataFetcher: class TimeService:   When prefix is required:  Public classes used across multiple modulesAll exception classesAll coordinator and entity classesData classes (dataclasses, NamedTuples) used as public APIs  When prefix can be omitted:  Private helper classes within a single module (prefix with _ underscore)Type aliases and callbacks (e.g., TimeServiceCallback)Small internal NamedTuples for function returns  Private Classes:  If a helper class is ONLY used within a single module file, prefix it with underscore:  # âœ… Private class - used only in this file class _InternalHelper: &quot;&quot;&quot;Helper used only within this module.&quot;&quot;&quot; pass # âŒ Wrong - no prefix but used across modules class DataFetcher: # Should be TibberPricesDataFetcher pass   Note: Currently (Nov 2025), this project has NO private classes - all classes are used across module boundaries.  Current Technical Debt:  Many existing classes lack the TibberPrices prefix. Before refactoring:  Document the plan in /planning/class-naming-refactoring.mdUse multi_replace_string_in_file for bulk renamesTest thoroughly after each module  See AGENTS.md for complete list of classes needing rename.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Import Orderâ€‹","type":1,"pageTitle":"Coding Guidelines","url":"/hass.tibber_prices/developer/coding-guidelines#import-order","content":" Python stdlib (specific types only)Third-party (homeassistant.*, aiohttp)Local (.api, .const)  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Critical Patternsâ€‹","type":1,"pageTitle":"Coding Guidelines","url":"/hass.tibber_prices/developer/coding-guidelines#critical-patterns","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Time Handlingâ€‹","type":1,"pageTitle":"Coding Guidelines","url":"/hass.tibber_prices/developer/coding-guidelines#time-handling","content":" Always use dt_util from homeassistant.util:  from homeassistant.util import dt as dt_util price_time = dt_util.parse_datetime(starts_at) price_time = dt_util.as_local(price_time) # Convert to HA timezone now = dt_util.now()   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Translation Loadingâ€‹","type":1,"pageTitle":"Coding Guidelines","url":"/hass.tibber_prices/developer/coding-guidelines#translation-loading","content":" # In __init__.py async_setup_entry: await async_load_translations(hass, &quot;en&quot;) await async_load_standard_translations(hass, &quot;en&quot;)   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Price Data Enrichmentâ€‹","type":1,"pageTitle":"Coding Guidelines","url":"/hass.tibber_prices/developer/coding-guidelines#price-data-enrichment","content":" Always enrich raw API data:  from .price_utils import enrich_price_info_with_differences enriched = enrich_price_info_with_differences( price_info_data, thresholds, )   See AGENTS.md for complete guidelines. ","version":"Next ğŸš§","tagName":"h3"},{"title":"Contributing Guide","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/contributing","content":"","keywords":"","version":"Next ğŸš§"},{"title":"Getting Startedâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#getting-started","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Prerequisitesâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#prerequisites","content":" GitVS Code with Remote Containers extensionDocker Desktop  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Fork and Cloneâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#fork-and-clone","content":" Fork the repository on GitHubClone your fork: git clone https://github.com/YOUR_USERNAME/hass.tibber_prices.git cd hass.tibber_prices Open in VS CodeClick &quot;Reopen in Container&quot; when prompted  The DevContainer will set up everything automatically.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Development Workflowâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#development-workflow","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"1. Create a Branchâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#1-create-a-branch","content":" git checkout -b feature/your-feature-name # or git checkout -b fix/issue-123-description   Branch naming:  feature/ - New featuresfix/ - Bug fixesdocs/ - Documentation onlyrefactor/ - Code restructuringtest/ - Test improvements  ","version":"Next ğŸš§","tagName":"h3"},{"title":"2. Make Changesâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#2-make-changes","content":" Edit code, following Coding Guidelines.  Run checks frequently:  ./scripts/type-check # Pyright type checking ./scripts/lint # Ruff linting (auto-fix) ./scripts/test # Run tests   ","version":"Next ğŸš§","tagName":"h3"},{"title":"3. Test Locallyâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#3-test-locally","content":" ./scripts/develop # Start HA with integration loaded   Access at http://localhost:8123  ","version":"Next ğŸš§","tagName":"h3"},{"title":"4. Write Testsâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#4-write-tests","content":" Add tests in /tests/ for new features:  @pytest.mark.unit async def test_your_feature(hass, coordinator): &quot;&quot;&quot;Test your new feature.&quot;&quot;&quot; # Arrange coordinator.data = {...} # Act result = your_function(coordinator.data) # Assert assert result == expected_value   Run your test:  ./scripts/test tests/test_your_feature.py -v   ","version":"Next ğŸš§","tagName":"h3"},{"title":"5. Commit Changesâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#5-commit-changes","content":" Follow Conventional Commits:  git add . git commit -m &quot;feat(sensors): add volatility trend sensor Add new sensor showing 3-hour volatility trend direction. Includes attributes with historical volatility data. Impact: Users can predict when prices will stabilize or continue fluctuating.&quot;   Commit types:  feat: - New featurefix: - Bug fixdocs: - Documentationrefactor: - Code restructuringtest: - Test changeschore: - Maintenance  Add scope when relevant:  feat(sensors): - Sensor platformfix(coordinator): - Data coordinatordocs(user): - User documentation  ","version":"Next ğŸš§","tagName":"h3"},{"title":"6. Push and Create PRâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#6-push-and-create-pr","content":" git push origin your-branch-name   Then open Pull Request on GitHub.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Pull Request Guidelinesâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#pull-request-guidelines","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"PR Templateâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#pr-template","content":" Title: Short, descriptive (50 chars max)  Description should include:  ## What Brief description of changes ## Why Problem being solved or feature rationale ## How Implementation approach ## Testing - [ ] Manual testing in Home Assistant - [ ] Unit tests added/updated - [ ] Type checking passes - [ ] Linting passes ## Breaking Changes (If any - describe migration path) ## Related Issues Closes #123   ","version":"Next ğŸš§","tagName":"h3"},{"title":"PR Checklistâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#pr-checklist","content":" Before submitting:   Code follows Coding Guidelines All tests pass (./scripts/test) Type checking passes (./scripts/type-check) Linting passes (./scripts/lint-check) Documentation updated (if needed) AGENTS.md updated (if patterns changed) Commit messages follow Conventional Commits  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Review Processâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#review-process","content":" Automated checks run (CI/CD)Maintainer review (usually within 3 days)Address feedback if requestedApproval â†’ Maintainer merges  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Code Review Tipsâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#code-review-tips","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"What Reviewers Look Forâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#what-reviewers-look-for","content":" âœ… Good:  Clear, self-explanatory codeAppropriate comments for complex logicTests covering edge casesType hints on all functionsFollows existing patterns  âŒ Avoid:  Large PRs (&gt;500 lines) - split into smaller onesMixing unrelated changesMissing tests for new featuresBreaking changes without migration pathCopy-pasted code (refactor into shared functions)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Responding to Feedbackâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#responding-to-feedback","content":" Don't take it personally - we're improving code togetherAsk questions if feedback unclearPush additional commits to address commentsMark conversations as resolved when fixed  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Finding Issues to Work Onâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#finding-issues-to-work-on","content":" Good first issues are labeled:  good first issue - Beginner-friendlyhelp wanted - Maintainers welcome contributionsdocumentation - Docs improvements  Comment on issue before starting work to avoid duplicates.  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Communicationâ€‹","type":1,"pageTitle":"Contributing Guide","url":"/hass.tibber_prices/developer/contributing#communication","content":" GitHub Issues - Bug reports, feature requestsPull Requests - Code discussionDiscussions - General questions, ideas  Be respectful, constructive, and patient. We're all volunteers! ğŸ™    ğŸ’¡ Related:  Setup Guide - DevContainer setupCoding Guidelines - Style guideTesting - Writing testsRelease Management - How releases work ","version":"Next ğŸš§","tagName":"h2"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/architecture","content":"","keywords":"","version":"Next ğŸš§"},{"title":"End-to-End Data Flowâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#end-to-end-data-flow","content":"   ","version":"Next ğŸš§","tagName":"h2"},{"title":"Flow Descriptionâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#flow-description","content":" Setup (__init__.py) Integration loads, creates coordinator instanceRegisters entity platforms (sensor, binary_sensor)Sets up custom services Data Fetch (every 15 minutes) Coordinator triggers update via api.pyAPI client checks persistent cache first (coordinator/cache.py)If cache valid â†’ return cached dataIf cache stale â†’ query Tibber GraphQL APIStore fresh data in persistent cache (survives HA restart) Price Enrichment Coordinator passes raw prices to DataTransformerTransformer checks transformation cache (memory)If cache valid â†’ return enriched dataIf cache invalid â†’ enrich via price_utils.py + average_utils.py Calculate 24h trailing/leading averagesCalculate price differences (% from average)Assign rating levels (LOW/NORMAL/HIGH) Store enriched data in transformation cache Period Calculation Coordinator passes enriched data to PeriodCalculatorCalculator computes hash from prices + configIf hash matches cache â†’ return cached periodsIf hash differs â†’ recalculate best/peak price periodsStore periods with new hash Entity Updates Coordinator provides complete data (prices + periods)Sensors read values via unified handlersBinary sensors evaluate period statesEntities update on quarter-hour boundaries (00/15/30/45) Service Calls Custom services access coordinator data directlyReturn formatted responses (JSON, ApexCharts format)    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Caching Architectureâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#caching-architecture","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Overviewâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#overview","content":" The integration uses 5 independent caching layers for optimal performance:  Layer\tLocation\tLifetime\tInvalidation\tMemoryAPI Cache\tcoordinator/cache.py\t24h (user) Until midnight (prices)\tAutomatic\t50KB Translation Cache\tconst.py\tUntil HA restart\tNever\t5KB Config Cache\tcoordinator/*\tUntil config change\tExplicit\t1KB Period Cache\tcoordinator/periods.py\tUntil data/config change\tHash-based\t10KB Transformation Cache\tcoordinator/data_transformation.py\tUntil midnight/config\tAutomatic\t60KB  Total cache overhead: ~126KB per coordinator instance (main entry + subentries)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Cache Coordinationâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#cache-coordination","content":"   Key insight: No cascading invalidations - each cache is independent and rebuilds on-demand.  For detailed cache behavior, see Caching Strategy.    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Component Responsibilitiesâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#component-responsibilities","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Core Componentsâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#core-components","content":" Component\tFile\tResponsibilityAPI Client\tapi.py\tGraphQL queries to Tibber, retry logic, error handling Coordinator\tcoordinator.py\tUpdate orchestration, cache management, absolute-time scheduling with boundary tolerance Data Transformer\tcoordinator/data_transformation.py\tPrice enrichment (averages, ratings, differences) Period Calculator\tcoordinator/periods.py\tBest/peak price period calculation with relaxation Sensors\tsensor/\t80+ entities for prices, levels, ratings, statistics Binary Sensors\tbinary_sensor/\tPeriod indicators (best/peak price active) Services\tservices/\tCustom service endpoints (get_chartdata, get_apexcharts_yaml, refresh_user_data)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Sensor Architecture (Calculator Pattern)â€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#sensor-architecture-calculator-pattern","content":" The sensor platform uses Calculator Pattern for clean separation of concerns (refactored Nov 2025):  Component\tFiles\tLines\tResponsibilityEntity Class\tsensor/core.py\t909\tEntity lifecycle, coordinator, delegates to calculators Calculators\tsensor/calculators/\t1,838\tBusiness logic (8 specialized calculators) Attributes\tsensor/attributes/\t1,209\tState presentation (8 specialized modules) Routing\tsensor/value_getters.py\t276\tCentralized sensor â†’ calculator mapping Chart Export\tsensor/chart_data.py\t144\tService call handling, YAML parsing Helpers\tsensor/helpers.py\t188\tAggregation functions, utilities  Calculator Package (sensor/calculators/):  base.py - Abstract BaseCalculator with coordinator accessinterval.py - Single interval calculations (current/next/previous)rolling_hour.py - 5-interval rolling windowsdaily_stat.py - Calendar day min/max/avg statisticswindow_24h.py - Trailing/leading 24h windowsvolatility.py - Price volatility analysistrend.py - Complex trend analysis with cachingtiming.py - Best/peak price period timingmetadata.py - Home/metering metadata  Benefits:  58% reduction in core.py (2,170 â†’ 909 lines)Clear separation: Calculators (logic) vs Attributes (presentation)Independent testability for each calculatorEasy to add sensors: Choose calculation pattern, add to routing  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Helper Utilitiesâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#helper-utilities","content":" Utility\tFile\tPurposePrice Utils\tutils/price.py\tRating calculation, enrichment, level aggregation Average Utils\tutils/average.py\tTrailing/leading 24h average calculations Entity Utils\tentity_utils/\tShared icon/color/attribute logic Translations\tconst.py\tTranslation loading and caching    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Key Patternsâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#key-patterns","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"1. Dual Translation Systemâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#1-dual-translation-system","content":" Standard translations (/translations/*.json): HA-compliant schema for entity namesCustom translations (/custom_translations/*.json): Extended descriptions, usage tipsBoth loaded at integration setup, cached in memoryAccess via get_translation() helper function  ","version":"Next ğŸš§","tagName":"h3"},{"title":"2. Price Data Enrichmentâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#2-price-data-enrichment","content":" All quarter-hourly price intervals get augmented via utils/price.py:  # Original from Tibber API { &quot;startsAt&quot;: &quot;2025-11-03T14:00:00+01:00&quot;, &quot;total&quot;: 0.2534, &quot;level&quot;: &quot;NORMAL&quot; } # After enrichment (utils/price.py) { &quot;startsAt&quot;: &quot;2025-11-03T14:00:00+01:00&quot;, &quot;total&quot;: 0.2534, &quot;level&quot;: &quot;NORMAL&quot;, &quot;trailing_avg_24h&quot;: 0.2312, # â† Added: 24h trailing average &quot;difference&quot;: 9.6, # â† Added: % diff from trailing avg &quot;rating_level&quot;: &quot;NORMAL&quot; # â† Added: LOW/NORMAL/HIGH based on thresholds }   ","version":"Next ğŸš§","tagName":"h3"},{"title":"3. Quarter-Hour Precisionâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#3-quarter-hour-precision","content":" API polling: Every 15 minutes (coordinator fetch cycle)Entity updates: On 00/15/30/45-minute boundaries via coordinator/listeners.pyTimer scheduling: Uses async_track_utc_time_change(minute=[0, 15, 30, 45], second=0) HA may trigger Â±few milliseconds before/after exact boundarySmart boundary tolerance (Â±2 seconds) handles scheduling jitter in sensor/helpers.pyIf HA schedules at 14:59:58 â†’ rounds to 15:00:00 (shows new interval data)If HA restarts at 14:59:30 â†’ stays at 14:45:00 (shows current interval data) Absolute time tracking: Timer plans for all future boundaries (not relative delays) Prevents double-updates (if triggered at 14:59:58, next trigger is 15:15:00, not 15:00:00) Result: Current price sensors update without waiting for next API poll  ","version":"Next ğŸš§","tagName":"h3"},{"title":"4. Calculator Pattern (Sensor Platform)â€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#4-calculator-pattern-sensor-platform","content":" Sensors organized by calculation method (refactored Nov 2025):  Unified Handler Methods (sensor/core.py):  _get_interval_value(offset, type) - current/next/previous intervals_get_rolling_hour_value(offset, type) - 5-interval rolling windows_get_daily_stat_value(day, stat_func) - calendar day min/max/avg_get_24h_window_value(stat_func) - trailing/leading statistics  Routing (sensor/value_getters.py):  Single source of truth mapping 80+ entity keys to calculator methodsOrganized by calculation type (Interval, Rolling Hour, Daily Stats, etc.)  Calculators (sensor/calculators/):  Each calculator inherits from BaseCalculator with coordinator accessFocused responsibility: IntervalCalculator, TrendCalculator, etc.Complex logic isolated (e.g., TrendCalculator has internal caching)  Attributes (sensor/attributes/):  Separate from business logic, handles state presentationBuilds extra_state_attributes dicts for entity classesUnified builders: build_sensor_attributes(), build_extra_state_attributes()  Benefits:  Minimal code duplication across 80+ sensorsClear separation of concerns (calculation vs presentation)Easy to extend: Add sensor â†’ choose pattern â†’ add to routingIndependent testability for each component    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Performance Characteristicsâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#performance-characteristics","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"API Call Reductionâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#api-call-reduction","content":" Without caching: 96 API calls/day (every 15 min)With caching: ~1-2 API calls/day (only when cache expires)Reduction: ~98%  ","version":"Next ğŸš§","tagName":"h3"},{"title":"CPU Optimizationâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#cpu-optimization","content":" Optimization\tLocation\tSavingsConfig caching\tcoordinator/*\t~50% on config checks Period caching\tcoordinator/periods.py\t~70% on period recalculation Lazy logging\tThroughout\t~15% on log-heavy operations Import optimization\tModule structure\t~20% faster loading  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Memory Usageâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#memory-usage","content":" Per coordinator instance: ~126KB cache overheadTypical setup: 1 main + 2 subentries = ~378KB totalRedundancy eliminated: 14% reduction (10KB saved per coordinator)    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Related Documentationâ€‹","type":1,"pageTitle":"Architecture","url":"/hass.tibber_prices/developer/architecture#related-documentation","content":" Timer Architecture - Timer system, scheduling, coordination (3 independent timers)Caching Strategy - Detailed cache behavior, invalidation, debuggingSetup Guide - Development environment setupTesting Guide - How to test changesRelease Management - Release workflow and versioningAGENTS.md - Complete reference for AI development ","version":"Next ğŸš§","tagName":"h2"},{"title":"Caching Strategy","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/caching-strategy","content":"","keywords":"","version":"Next ğŸš§"},{"title":"Overviewâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#overview","content":" The integration uses 4 distinct caching layers with different purposes and lifetimes:  Persistent API Data Cache (HA Storage) - Hours to daysTranslation Cache (Memory) - Forever (until HA restart)Config Dictionary Cache (Memory) - Until config changesPeriod Calculation Cache (Memory) - Until price data or config changes  ","version":"Next ğŸš§","tagName":"h2"},{"title":"1. Persistent API Data Cacheâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#1-persistent-api-data-cache","content":" Location: coordinator/cache.py â†’ HA Storage (.storage/tibber_prices.&lt;entry_id&gt;)  Purpose: Reduce API calls to Tibber by caching user data and price data between HA restarts.  What is cached:  Price data (price_data): Day before yesterday/yesterday/today/tomorrow price intervals with enriched fields (384 intervals total)User data (user_data): Homes, subscriptions, features from Tibber GraphQL viewer queryTimestamps: Last update times for validation  Lifetime:  Price data: Until midnight turnover (cleared daily at 00:00 local time)User data: 24 hours (refreshed daily)Survives: HA restarts via persistent Storage  Invalidation triggers:  Midnight turnover (Timer #2 in coordinator): # coordinator/day_transitions.py def _handle_midnight_turnover() -&gt; None: self._cached_price_data = None # Force fresh fetch for new day self._last_price_update = None await self.store_cache() Cache validation on load: # coordinator/cache.py def is_cache_valid(cache_data: CacheData) -&gt; bool: # Checks if price data is from a previous day if today_date &lt; local_now.date(): # Yesterday's data return False Tomorrow data check (after 13:00): # coordinator/data_fetching.py if tomorrow_missing or tomorrow_invalid: return &quot;tomorrow_check&quot; # Update needed   Why this cache matters: Reduces API load on Tibber (~192 intervals per fetch), speeds up HA restarts, enables offline operation until cache expires.    ","version":"Next ğŸš§","tagName":"h2"},{"title":"2. Translation Cacheâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#2-translation-cache","content":" Location: const.py â†’ _TRANSLATIONS_CACHE and _STANDARD_TRANSLATIONS_CACHE (in-memory dicts)  Purpose: Avoid repeated file I/O when accessing entity descriptions, UI strings, etc.  What is cached:  Standard translations (/translations/*.json): Config flow, selector options, entity namesCustom translations (/custom_translations/*.json): Entity descriptions, usage tips, long descriptions  Lifetime:  Forever (until HA restart)No invalidation during runtime  When populated:  At integration setup: async_load_translations(hass, &quot;en&quot;) in __init__.pyLazy loading: If translation missing, attempts file load once  Access pattern:  # Non-blocking synchronous access from cached data description = get_translation(&quot;binary_sensor.best_price_period.description&quot;, &quot;en&quot;)   Why this cache matters: Entity attributes are accessed on every state update (~15 times per hour per entity). File I/O would block the event loop. Cache enables synchronous, non-blocking attribute generation.    ","version":"Next ğŸš§","tagName":"h2"},{"title":"3. Config Dictionary Cacheâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#3-config-dictionary-cache","content":" Location: coordinator/data_transformation.py and coordinator/periods.py (per-instance fields)  Purpose: Avoid ~30-40 options.get() calls on every coordinator update (every 15 minutes).  What is cached:  ","version":"Next ğŸš§","tagName":"h2"},{"title":"DataTransformer Config Cacheâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#datatransformer-config-cache","content":" { &quot;thresholds&quot;: {&quot;low&quot;: 15, &quot;high&quot;: 35}, &quot;volatility_thresholds&quot;: {&quot;moderate&quot;: 15.0, &quot;high&quot;: 25.0, &quot;very_high&quot;: 40.0}, # ... 20+ more config fields }   ","version":"Next ğŸš§","tagName":"h3"},{"title":"PeriodCalculator Config Cacheâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#periodcalculator-config-cache","content":" { &quot;best&quot;: {&quot;flex&quot;: 0.15, &quot;min_distance_from_avg&quot;: 5.0, &quot;min_period_length&quot;: 60}, &quot;peak&quot;: {&quot;flex&quot;: 0.15, &quot;min_distance_from_avg&quot;: 5.0, &quot;min_period_length&quot;: 60} }   Lifetime:  Until invalidate_config_cache() is calledBuilt once on first use per coordinator update cycle  Invalidation trigger:  Options change (user reconfigures integration): # coordinator/core.py async def _handle_options_update(...) -&gt; None: self._data_transformer.invalidate_config_cache() self._period_calculator.invalidate_config_cache() await self.async_request_refresh()   Performance impact:  Before: ~30 dict lookups + type conversions per update = ~50Î¼sAfter: 1 cache check = ~1Î¼sSavings: ~98% (50Î¼s â†’ 1Î¼s per update)  Why this cache matters: Config is read multiple times per update (transformation + period calculation + validation). Caching eliminates redundant lookups without changing behavior.    ","version":"Next ğŸš§","tagName":"h3"},{"title":"4. Period Calculation Cacheâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#4-period-calculation-cache","content":" Location: coordinator/periods.py â†’ PeriodCalculator._cached_periods  Purpose: Avoid expensive period calculations (~100-500ms) when price data and config haven't changed.  What is cached:  { &quot;best_price&quot;: { &quot;periods&quot;: [...], # Calculated period objects &quot;intervals&quot;: [...], # All intervals in periods &quot;metadata&quot;: {...} # Config snapshot }, &quot;best_price_relaxation&quot;: {&quot;relaxation_active&quot;: bool, ...}, &quot;peak_price&quot;: {...}, &quot;peak_price_relaxation&quot;: {...} }   Cache key: Hash of relevant inputs  hash_data = ( today_signature, # (startsAt, rating_level) for each interval tuple(best_config.items()), # Best price config tuple(peak_config.items()), # Peak price config best_level_filter, # Level filter overrides peak_level_filter )   Lifetime:  Until price data changes (today's intervals modified)Until config changes (flex, thresholds, filters)Recalculated at midnight (new today data)  Invalidation triggers:  Config change (explicit): def invalidate_config_cache() -&gt; None: self._cached_periods = None self._last_periods_hash = None Price data change (automatic via hash mismatch): current_hash = self._compute_periods_hash(price_info) if self._last_periods_hash != current_hash: # Cache miss - recalculate   Cache hit rate:  High: During normal operation (coordinator updates every 15min, price data unchanged)Low: After midnight (new today data) or when tomorrow data arrives (~13:00-14:00)  Performance impact:  Period calculation: ~100-500ms (depends on interval count, relaxation attempts)Cache hit: &lt;1ms (hash comparison + dict lookup)Savings: ~70% of calculation time (most updates hit cache)  Why this cache matters: Period calculation is CPU-intensive (filtering, gap tolerance, relaxation). Caching avoids recalculating unchanged periods 3-4 times per hour.    ","version":"Next ğŸš§","tagName":"h2"},{"title":"5. Transformation Cache (Price Enrichment Only)â€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#5-transformation-cache-price-enrichment-only","content":" Location: coordinator/data_transformation.py â†’ _cached_transformed_data  Status: âœ… Clean separation - enrichment only, no redundancy  What is cached:  { &quot;timestamp&quot;: ..., &quot;homes&quot;: {...}, &quot;priceInfo&quot;: {...}, # Enriched price data (trailing_avg_24h, difference, rating_level) # NO periods - periods are exclusively managed by PeriodCalculator }   Purpose: Avoid re-enriching price data when config unchanged between midnight checks.  Current behavior:  Caches only enriched price data (price + statistics)Does NOT cache periods (handled by Period Calculation Cache)Invalidated when: Config changes (thresholds affect enrichment)Midnight turnover detectedNew update cycle begins  Architecture:  DataTransformer: Handles price enrichment onlyPeriodCalculator: Handles period calculation only (with hash-based cache)Coordinator: Assembles final data on-demand from both caches  Memory savings: Eliminating redundant period storage saves ~10KB per coordinator (14% reduction).    ","version":"Next ğŸš§","tagName":"h2"},{"title":"Cache Invalidation Flowâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#cache-invalidation-flow","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"User Changes Options (Config Flow)â€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#user-changes-options-config-flow","content":" User saves options â†“ config_entry.add_update_listener() triggers â†“ coordinator._handle_options_update() â†“ â”œâ”€&gt; DataTransformer.invalidate_config_cache() â”‚ â””â”€&gt; _config_cache = None â”‚ _config_cache_valid = False â”‚ _cached_transformed_data = None â”‚ â””â”€&gt; PeriodCalculator.invalidate_config_cache() â””â”€&gt; _config_cache = None _config_cache_valid = False _cached_periods = None _last_periods_hash = None â†“ coordinator.async_request_refresh() â†“ Fresh data fetch with new config   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Midnight Turnover (Day Transition)â€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#midnight-turnover-day-transition","content":" Timer #2 fires at 00:00 â†“ coordinator._handle_midnight_turnover() â†“ â”œâ”€&gt; Clear persistent cache â”‚ â””â”€&gt; _cached_price_data = None â”‚ _last_price_update = None â”‚ â””â”€&gt; Clear transformation cache â””â”€&gt; _cached_transformed_data = None _last_transformation_config = None â†“ Period cache auto-invalidates (hash mismatch on new &quot;today&quot;) â†“ Fresh API fetch for new day   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Tomorrow Data Arrives (~13:00)â€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#tomorrow-data-arrives-1300","content":" Coordinator update cycle â†“ should_update_price_data() checks tomorrow â†“ Tomorrow data missing/invalid â†“ API fetch with new tomorrow data â†“ Price data hash changes (new intervals) â†“ Period cache auto-invalidates (hash mismatch) â†“ Periods recalculated with tomorrow included     ","version":"Next ğŸš§","tagName":"h3"},{"title":"Cache Coordinationâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#cache-coordination","content":" All caches work together:  Persistent Storage (HA restart) â†“ API Data Cache (price_data, user_data) â†“ â”œâ”€&gt; Enrichment (add rating_level, difference, etc.) â”‚ â†“ â”‚ Transformation Cache (_cached_transformed_data) â”‚ â””â”€&gt; Period Calculation â†“ Period Cache (_cached_periods) â†“ Config Cache (avoid re-reading options) â†“ Translation Cache (entity descriptions)   No cache invalidation cascades:  Config cache invalidation is explicit (on options update)Period cache invalidation is automatic (via hash mismatch)Transformation cache invalidation is automatic (on midnight/config change)Translation cache is never invalidated (read-only after load)  Thread safety:  All caches are accessed from MainThread only (Home Assistant event loop)No locking needed (single-threaded execution model)    ","version":"Next ğŸš§","tagName":"h2"},{"title":"Performance Characteristicsâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#performance-characteristics","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Typical Operation (No Changes)â€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#typical-operation-no-changes","content":" Coordinator Update (every 15 min) â”œâ”€&gt; API fetch: SKIP (cache valid) â”œâ”€&gt; Config dict build: ~1Î¼s (cached) â”œâ”€&gt; Period calculation: ~1ms (cached, hash match) â”œâ”€&gt; Transformation: ~10ms (enrichment only, periods cached) â””â”€&gt; Entity updates: ~5ms (translation cache hit) Total: ~16ms (down from ~600ms without caching)   ","version":"Next ğŸš§","tagName":"h3"},{"title":"After Midnight Turnoverâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#after-midnight-turnover","content":" Coordinator Update (00:00) â”œâ”€&gt; API fetch: ~500ms (cache cleared, fetch new day) â”œâ”€&gt; Config dict build: ~50Î¼s (rebuild, no cache) â”œâ”€&gt; Period calculation: ~200ms (cache miss, recalculate) â”œâ”€&gt; Transformation: ~50ms (re-enrich, rebuild) â””â”€&gt; Entity updates: ~5ms (translation cache still valid) Total: ~755ms (expected once per day)   ","version":"Next ğŸš§","tagName":"h3"},{"title":"After Config Changeâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#after-config-change","content":" Options Update â”œâ”€&gt; Cache invalidation: `&lt;`1ms â”œâ”€&gt; Coordinator refresh: ~600ms â”‚ â”œâ”€&gt; API fetch: SKIP (data unchanged) â”‚ â”œâ”€&gt; Config rebuild: ~50Î¼s â”‚ â”œâ”€&gt; Period recalculation: ~200ms (new thresholds) â”‚ â”œâ”€&gt; Re-enrichment: ~50ms â”‚ â””â”€&gt; Entity updates: ~5ms â””â”€&gt; Total: ~600ms (expected on manual reconfiguration)     ","version":"Next ğŸš§","tagName":"h3"},{"title":"Summary Tableâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#summary-table","content":" Cache Type\tLifetime\tSize\tInvalidation\tPurposeAPI Data\tHours to 1 day\t~50KB\tMidnight, validation\tReduce API calls Translations\tForever (until HA restart)\t~5KB\tNever\tAvoid file I/O Config Dicts\tUntil options change\t&lt;1KB\tExplicit (options update)\tAvoid dict lookups Period Calculation\tUntil data/config change\t~10KB\tAuto (hash mismatch)\tAvoid CPU-intensive calculation Transformation\tUntil midnight/config change\t~50KB\tAuto (midnight/config)\tAvoid re-enrichment  Total memory overhead: ~116KB per coordinator instance (main + subentries)  Benefits:  97% reduction in API calls (from every 15min to once per day)70% reduction in period calculation time (cache hits during normal operation)98% reduction in config access time (30+ lookups â†’ 1 cache check)Zero file I/O during runtime (translations cached at startup)  Trade-offs:  Memory usage: ~116KB per home (negligible for modern systems)Code complexity: 5 cache invalidation points (well-tested, documented)Debugging: Must understand cache lifetime when investigating stale data issues    ","version":"Next ğŸš§","tagName":"h2"},{"title":"Debugging Cache Issuesâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#debugging-cache-issues","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Symptom: Stale data after config changeâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#symptom-stale-data-after-config-change","content":" Check:  Is _handle_options_update() called? (should see &quot;Options updated&quot; log)Are invalidate_config_cache() methods executed?Does async_request_refresh() trigger?  Fix: Ensure config_entry.add_update_listener() is registered in coordinator init.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Symptom: Period calculation not updatingâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#symptom-period-calculation-not-updating","content":" Check:  Verify hash changes when data changes: _compute_periods_hash()Check _last_periods_hash vs current_hashLook for &quot;Using cached period calculation&quot; vs &quot;Calculating periods&quot; logs  Fix: Hash function may not include all relevant data. Review _compute_periods_hash() inputs.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Symptom: Yesterday's prices shown as todayâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#symptom-yesterdays-prices-shown-as-today","content":" Check:  is_cache_valid() logic in coordinator/cache.pyMidnight turnover execution (Timer #2)Cache clear confirmation in logs  Fix: Timer may not be firing. Check _schedule_midnight_turnover() registration.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Symptom: Missing translationsâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#symptom-missing-translations","content":" Check:  async_load_translations() called at startup?Translation files exist in /translations/ and /custom_translations/?Cache population: _TRANSLATIONS_CACHE keys  Fix: Re-install integration or restart HA to reload translation files.    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Related Documentationâ€‹","type":1,"pageTitle":"Caching Strategy","url":"/hass.tibber_prices/developer/caching-strategy#related-documentation","content":" Timer Architecture - Timer system, scheduling, midnight coordinationArchitecture - Overall system design, data flowAGENTS.md - Complete reference for AI development ","version":"Next ğŸš§","tagName":"h2"},{"title":"Critical Behavior Patterns - Testing Guide","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/critical-patterns","content":"","keywords":"","version":"Next ğŸš§"},{"title":"ğŸ¯ Why Are These Tests Critical?â€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#-why-are-these-tests-critical","content":" Home Assistant integrations run continuously in the background. Resource leaks lead to:  Memory Leaks: RAM usage grows over days/weeks until HA becomes unstableCallback Leaks: Listeners remain registered after entity removal â†’ CPU load increasesTimer Leaks: Timers continue running after unload â†’ unnecessary background tasksFile Handle Leaks: Storage files remain open â†’ system resources exhausted  ","version":"Next ğŸš§","tagName":"h2"},{"title":"âœ… Test Categoriesâ€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#-test-categories","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"1. Resource Cleanup (Memory Leak Prevention)â€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#1-resource-cleanup-memory-leak-prevention","content":" File: tests/test_resource_cleanup.py  1.1 Listener Cleanup âœ…â€‹  What is tested:  Time-sensitive listeners are correctly removed (async_add_time_sensitive_listener())Minute-update listeners are correctly removed (async_add_minute_update_listener())Lifecycle callbacks are correctly unregistered (register_lifecycle_callback())Sensor cleanup removes ALL registered listenersBinary sensor cleanup removes ALL registered listeners  Why critical:  Each registered listener holds references to Entity + CoordinatorWithout cleanup: Entities are not freed by GC â†’ Memory LeakWith 80+ sensors Ã— 3 listener types = 240+ callbacks that must be cleanly removed  Code Locations:  coordinator/listeners.py â†’ async_add_time_sensitive_listener(), async_add_minute_update_listener()coordinator/core.py â†’ register_lifecycle_callback()sensor/core.py â†’ async_will_remove_from_hass()binary_sensor/core.py â†’ async_will_remove_from_hass()  1.2 Timer Cleanup âœ…â€‹  What is tested:  Quarter-hour timer is cancelled and reference clearedMinute timer is cancelled and reference clearedBoth timers are cancelled togetherCleanup works even when timers are None  Why critical:  Uncancelled timers continue running after integration unloadHA's async_track_utc_time_change() creates persistent callbacksWithout cleanup: Timers keep firing â†’ CPU load + unnecessary coordinator updates  Code Locations:  coordinator/listeners.py â†’ cancel_timers()coordinator/core.py â†’ async_shutdown()  1.3 Config Entry Cleanup âœ…â€‹  What is tested:  Options update listener is registered via async_on_unload()Cleanup function is correctly passed to async_on_unload()  Why critical:  entry.add_update_listener() registers permanent callbackWithout async_on_unload(): Listener remains active after reload â†’ duplicate updatesPattern: entry.async_on_unload(entry.add_update_listener(handler))  Code Locations:  coordinator/core.py â†’ __init__() (listener registration)__init__.py â†’ async_unload_entry()  ","version":"Next ğŸš§","tagName":"h3"},{"title":"2. Cache Invalidation âœ…â€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#2-cache-invalidation-","content":" File: tests/test_resource_cleanup.py  2.1 Config Cache Invalidationâ€‹  What is tested:  DataTransformer config cache is invalidated on options changePeriodCalculator config + period cache is invalidatedTrend calculator cache is cleared on coordinator update  Why critical:  Stale config â†’ Sensors use old user settingsStale period cache â†’ Incorrect best/peak price periodsStale trend cache â†’ Outdated trend analysis  Code Locations:  coordinator/data_transformation.py â†’ invalidate_config_cache()coordinator/periods.py â†’ invalidate_config_cache()sensor/calculators/trend.py â†’ clear_trend_cache()  ","version":"Next ğŸš§","tagName":"h3"},{"title":"3. Storage Cleanup âœ…â€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#3-storage-cleanup-","content":" File: tests/test_resource_cleanup.py + tests/test_coordinator_shutdown.py  3.1 Persistent Storage Removalâ€‹  What is tested:  Storage file is deleted on config entry removalCache is saved on shutdown (no data loss)  Why critical:  Without storage removal: Old files remain after uninstallationWithout cache save on shutdown: Data loss on HA restartStorage path: .storage/tibber_prices.{entry_id}  Code Locations:  __init__.py â†’ async_remove_entry()coordinator/core.py â†’ async_shutdown()  ","version":"Next ğŸš§","tagName":"h3"},{"title":"4. Timer Scheduling âœ…â€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#4-timer-scheduling-","content":" File: tests/test_timer_scheduling.py  What is tested:  Quarter-hour timer is registered with correct parametersMinute timer is registered with correct parametersTimers can be re-scheduled (override old timer)Midnight turnover detection works correctly  Why critical:  Wrong timer parameters â†’ Entities update at wrong timesWithout timer override on re-schedule â†’ Multiple parallel timers â†’ Performance problem  ","version":"Next ğŸš§","tagName":"h3"},{"title":"5. Sensor-to-Timer Assignment âœ…â€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#5-sensor-to-timer-assignment-","content":" File: tests/test_sensor_timer_assignment.py  What is tested:  All TIME_SENSITIVE_ENTITY_KEYS are valid entity keysAll MINUTE_UPDATE_ENTITY_KEYS are valid entity keysBoth lists are disjoint (no overlap)Sensor and binary sensor platforms are checked  Why critical:  Wrong timer assignment â†’ Sensors update at wrong timesOverlap â†’ Duplicate updates â†’ Performance problem  ","version":"Next ğŸš§","tagName":"h3"},{"title":"ğŸš¨ Additional Analysis (Nice-to-Have Patterns)â€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#-additional-analysis-nice-to-have-patterns","content":" These patterns were analyzed and classified as not critical:  ","version":"Next ğŸš§","tagName":"h2"},{"title":"6. Async Task Managementâ€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#6-async-task-management","content":" Current Status: Fire-and-forget pattern for short tasks  sensor/core.py â†’ Chart data refresh (short-lived, max 1-2 seconds)coordinator/core.py â†’ Cache storage (short-lived, max 100ms)  Why no tests needed:  No long-running tasks (all &lt; 2 seconds)HA's event loop handles short tasks automaticallyTask exceptions are already logged  If needed: _chart_refresh_task tracking + cancel in async_will_remove_from_hass()  ","version":"Next ğŸš§","tagName":"h3"},{"title":"7. API Session Cleanupâ€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#7-api-session-cleanup","content":" Current Status: âœ… Correctly implemented  async_get_clientsession(hass) is used (shared session)No new sessions are createdHA manages session lifecycle automatically  Code: api/client.py + __init__.py  ","version":"Next ğŸš§","tagName":"h3"},{"title":"8. Translation Cache Memoryâ€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#8-translation-cache-memory","content":" Current Status: âœ… Bounded cache  Max ~5-10 languages Ã— 5KB = 50KB totalModule-level cache without re-loadingPractically no memory issue  Code: const.py â†’ _TRANSLATIONS_CACHE, _STANDARD_TRANSLATIONS_CACHE  ","version":"Next ğŸš§","tagName":"h3"},{"title":"9. Coordinator Data Structure Integrityâ€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#9-coordinator-data-structure-integrity","content":" Current Status: Manually tested via ./scripts/develop  Midnight turnover works correctly (observed over several days)Missing keys are handled via .get() with defaults80+ sensors access coordinator.data without errors  Structure:  coordinator.data = { &quot;user_data&quot;: {...}, &quot;priceInfo&quot;: [...], # Flat list of all enriched intervals &quot;currency&quot;: &quot;EUR&quot; # Top-level for easy access }   ","version":"Next ğŸš§","tagName":"h3"},{"title":"10. Service Response Memoryâ€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#10-service-response-memory","content":" Current Status: HA's response lifecycle  HA automatically frees service responses after returnApexCharts ~20KB response is one-time per callNo response accumulation in integration code  Code: services/apexcharts.py  ","version":"Next ğŸš§","tagName":"h3"},{"title":"ğŸ“Š Test Coverage Statusâ€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#-test-coverage-status","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"âœ… Implemented Tests (41 total)â€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#-implemented-tests-41-total","content":" Category\tStatus\tTests\tFile\tCoverageListener Cleanup\tâœ…\t5\ttest_resource_cleanup.py\t100% Timer Cleanup\tâœ…\t4\ttest_resource_cleanup.py\t100% Config Entry Cleanup\tâœ…\t1\ttest_resource_cleanup.py\t100% Cache Invalidation\tâœ…\t3\ttest_resource_cleanup.py\t100% Storage Cleanup\tâœ…\t1\ttest_resource_cleanup.py\t100% Storage Persistence\tâœ…\t2\ttest_coordinator_shutdown.py\t100% Timer Scheduling\tâœ…\t8\ttest_timer_scheduling.py\t100% Sensor-Timer Assignment\tâœ…\t17\ttest_sensor_timer_assignment.py\t100% TOTAL\tâœ…\t41 100% (critical)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"ğŸ“‹ Analyzed but Not Implemented (Nice-to-Have)â€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#-analyzed-but-not-implemented-nice-to-have","content":" Category\tStatus\tRationaleAsync Task Management\tğŸ“‹\tFire-and-forget pattern used (no long-running tasks) API Session Cleanup\tâœ…\tPattern correct (async_get_clientsession used) Translation Cache\tâœ…\tCache size bounded (~50KB max for 10 languages) Data Structure Integrity\tğŸ“‹\tWould add test time without finding real issues Service Response Memory\tğŸ“‹\tHA automatically frees service responses  Legend:  âœ… = Fully tested or pattern verified correctğŸ“‹ = Analyzed, low priority for testing (no known issues)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"ğŸ¯ Development Statusâ€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#-development-status","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"âœ… All Critical Patterns Testedâ€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#-all-critical-patterns-tested","content":" All essential memory leak prevention patterns are covered by 41 tests:  âœ… Listeners are correctly removed (no callback leaks)âœ… Timers are cancelled (no background task leaks)âœ… Config entry cleanup works (no dangling listeners)âœ… Caches are invalidated (no stale data issues)âœ… Storage is saved and cleaned up (no data loss)âœ… Timer scheduling works correctly (no update issues)âœ… Sensor-timer assignment is correct (no wrong updates)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"ğŸ“‹ Nice-to-Have Tests (Optional)â€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#-nice-to-have-tests-optional","content":" If problems arise in the future, these tests can be added:  Async Task Management - Pattern analyzed (fire-and-forget for short tasks)Data Structure Integrity - Midnight rotation manually testedService Response Memory - HA's response lifecycle automatic  Conclusion: The integration has production-quality test coverage for all critical resource leak patterns.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"ğŸ” How to Run Testsâ€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#-how-to-run-tests","content":" # Run all resource cleanup tests (14 tests) ./scripts/test tests/test_resource_cleanup.py -v # Run all critical pattern tests (41 tests) ./scripts/test tests/test_resource_cleanup.py tests/test_coordinator_shutdown.py \\ tests/test_timer_scheduling.py tests/test_sensor_timer_assignment.py -v # Run all tests with coverage ./scripts/test --cov=custom_components.tibber_prices --cov-report=html # Type checking and linting ./scripts/check # Manual memory leak test # 1. Start HA: ./scripts/develop # 2. Monitor RAM: watch -n 1 'ps aux | grep home-assistant' # 3. Reload integration multiple times (HA UI: Settings â†’ Devices â†’ Tibber Prices â†’ Reload) # 4. RAM should stabilize (not grow continuously)   ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ“š Referencesâ€‹","type":1,"pageTitle":"Critical Behavior Patterns - Testing Guide","url":"/hass.tibber_prices/developer/critical-patterns#-references","content":" Home Assistant Cleanup Patterns: https://developers.home-assistant.io/docs/integration_setup_failures/#cleanupAsync Best Practices: https://developers.home-assistant.io/docs/asyncio_101/Memory Profiling: https://docs.python.org/3/library/tracemalloc.html ","version":"Next ğŸš§","tagName":"h2"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/api-reference","content":"","keywords":"","version":"Next ğŸš§"},{"title":"GraphQL Endpointâ€‹","type":1,"pageTitle":"API Reference","url":"/hass.tibber_prices/developer/api-reference#graphql-endpoint","content":" https://api.tibber.com/v1-beta/gql   Authentication: Bearer token in Authorization header  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Queries Usedâ€‹","type":1,"pageTitle":"API Reference","url":"/hass.tibber_prices/developer/api-reference#queries-used","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"User Data Queryâ€‹","type":1,"pageTitle":"API Reference","url":"/hass.tibber_prices/developer/api-reference#user-data-query","content":" Fetches home information and metadata:  query { viewer { homes { id appNickname address { address1 postalCode city country } timeZone currentSubscription { priceInfo { current { currency } } } meteringPointData { consumptionEan gridAreaCode } } } }   Cached for: 24 hours  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Price Data Queryâ€‹","type":1,"pageTitle":"API Reference","url":"/hass.tibber_prices/developer/api-reference#price-data-query","content":" Fetches quarter-hourly prices:  query($homeId: ID!) { viewer { home(id: $homeId) { currentSubscription { priceInfo { range(resolution: QUARTER_HOURLY, first: 384) { nodes { total startsAt level } } } } } } }   Parameters:  homeId: Tibber home identifierresolution: Always QUARTER_HOURLYfirst: 384 intervals (4 days of data)  Cached until: Midnight local time  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Rate Limitsâ€‹","type":1,"pageTitle":"API Reference","url":"/hass.tibber_prices/developer/api-reference#rate-limits","content":" Tibber API rate limits (as of 2024):  5000 requests per hour per tokenBurst limit: 100 requests per minute  Integration stays well below these limits:  Polls every 15 minutes = 96 requests/dayUser data cached for 24h = 1 request/dayTotal: ~100 requests/day per home  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Response Formatâ€‹","type":1,"pageTitle":"API Reference","url":"/hass.tibber_prices/developer/api-reference#response-format","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Price Node Structureâ€‹","type":1,"pageTitle":"API Reference","url":"/hass.tibber_prices/developer/api-reference#price-node-structure","content":" { &quot;total&quot;: 0.2456, &quot;startsAt&quot;: &quot;2024-12-06T14:00:00.000+01:00&quot;, &quot;level&quot;: &quot;NORMAL&quot; }   Fields:  total: Price including VAT and fees (currency's major unit, e.g., EUR)startsAt: ISO 8601 timestamp with timezonelevel: Tibber's own classification (VERY_CHEAP, CHEAP, NORMAL, EXPENSIVE, VERY_EXPENSIVE)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Currency Informationâ€‹","type":1,"pageTitle":"API Reference","url":"/hass.tibber_prices/developer/api-reference#currency-information","content":" { &quot;currency&quot;: &quot;EUR&quot; }   Supported currencies:  EUR (Euro) - displayed as ct/kWhNOK (Norwegian Krone) - displayed as Ã¸re/kWhSEK (Swedish Krona) - displayed as Ã¶re/kWh  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Error Handlingâ€‹","type":1,"pageTitle":"API Reference","url":"/hass.tibber_prices/developer/api-reference#error-handling","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Common Error Responsesâ€‹","type":1,"pageTitle":"API Reference","url":"/hass.tibber_prices/developer/api-reference#common-error-responses","content":" Invalid Token:  { &quot;errors&quot;: [{ &quot;message&quot;: &quot;Unauthorized&quot;, &quot;extensions&quot;: { &quot;code&quot;: &quot;UNAUTHENTICATED&quot; } }] }   Rate Limit Exceeded:  { &quot;errors&quot;: [{ &quot;message&quot;: &quot;Too Many Requests&quot;, &quot;extensions&quot;: { &quot;code&quot;: &quot;RATE_LIMIT_EXCEEDED&quot; } }] }   Home Not Found:  { &quot;errors&quot;: [{ &quot;message&quot;: &quot;Home not found&quot;, &quot;extensions&quot;: { &quot;code&quot;: &quot;NOT_FOUND&quot; } }] }   Integration handles these with:  Exponential backoff retry (3 attempts)ConfigEntryAuthFailed for auth errorsConfigEntryNotReady for temporary failures  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Data Transformationâ€‹","type":1,"pageTitle":"API Reference","url":"/hass.tibber_prices/developer/api-reference#data-transformation","content":" Raw API data is enriched with:  Trailing 24h average - Calculated from previous intervalsLeading 24h average - Calculated from future intervalsPrice difference % - Deviation from averageCustom rating - Based on user thresholds (different from Tibber's level)  See utils/price.py for enrichment logic.    ğŸ’¡ External Resources:  Tibber API DocumentationGraphQL ExplorerGet API Token ","version":"Next ğŸš§","tagName":"h2"},{"title":"Debugging Guide","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/debugging","content":"","keywords":"","version":"Next ğŸš§"},{"title":"Loggingâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#logging","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Enable Debug Loggingâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#enable-debug-logging","content":" Add to configuration.yaml:  logger: default: info logs: custom_components.tibber_prices: debug   Restart Home Assistant to apply.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Key Log Messagesâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#key-log-messages","content":" Coordinator Updates:  [custom_components.tibber_prices.coordinator] Successfully fetched price data [custom_components.tibber_prices.coordinator] Cache valid, using cached data [custom_components.tibber_prices.coordinator] Midnight turnover detected, clearing cache   Period Calculation:  [custom_components.tibber_prices.coordinator.periods] Calculating BEST PRICE periods: flex=15.0% [custom_components.tibber_prices.coordinator.periods] Day 2024-12-06: Found 2 periods [custom_components.tibber_prices.coordinator.periods] Period 1: 02:00-05:00 (12 intervals)   API Errors:  [custom_components.tibber_prices.api] API request failed: Unauthorized [custom_components.tibber_prices.api] Retrying (attempt 2/3) after 2.0s   ","version":"Next ğŸš§","tagName":"h3"},{"title":"VS Code Debuggingâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#vs-code-debugging","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Launch Configurationâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#launch-configuration","content":" .vscode/launch.json:  { &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Home Assistant&quot;, &quot;type&quot;: &quot;debugpy&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;module&quot;: &quot;homeassistant&quot;, &quot;args&quot;: [&quot;-c&quot;, &quot;config&quot;, &quot;--debug&quot;], &quot;justMyCode&quot;: false, &quot;env&quot;: { &quot;PYTHONPATH&quot;: &quot;${workspaceFolder}/.venv/lib/python3.13/site-packages&quot; } } ] }   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Set Breakpointsâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#set-breakpoints","content":" Coordinator update:  # coordinator/core.py async def _async_update_data(self) -&gt; dict: &quot;&quot;&quot;Fetch data from API.&quot;&quot;&quot; breakpoint() # Or set VS Code breakpoint   Period calculation:  # coordinator/period_handlers/core.py def calculate_periods(...) -&gt; list[dict]: &quot;&quot;&quot;Calculate best/peak price periods.&quot;&quot;&quot; breakpoint()   ","version":"Next ğŸš§","tagName":"h3"},{"title":"pytest Debuggingâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#pytest-debugging","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Run Single Test with Outputâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#run-single-test-with-output","content":" .venv/bin/python -m pytest tests/test_period_calculation.py::test_midnight_crossing -v -s   Flags:  -v - Verbose output-s - Show print statements-k pattern - Run tests matching pattern  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Debug Test in VS Codeâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#debug-test-in-vs-code","content":" Set breakpoint in test file, use &quot;Debug Test&quot; CodeLens.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Useful Test Patternsâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#useful-test-patterns","content":" Print coordinator data:  def test_something(coordinator): print(f&quot;Coordinator data: {coordinator.data}&quot;) print(f&quot;Price info count: {len(coordinator.data['priceInfo'])}&quot;)   Inspect period attributes:  def test_periods(hass, coordinator): periods = coordinator.data.get('best_price_periods', []) for period in periods: print(f&quot;Period: {period['start']} to {period['end']}&quot;) print(f&quot; Intervals: {len(period['intervals'])}&quot;)   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Common Issuesâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#common-issues","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Integration Not Loadingâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#integration-not-loading","content":" Check:  grep &quot;tibber_prices&quot; config/home-assistant.log   Common causes:  Syntax error in Python code â†’ Check logs for tracebackMissing dependency â†’ Run uv syncWrong file permissions â†’ chmod +x scripts/*  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Sensors Not Updatingâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#sensors-not-updating","content":" Check coordinator state:  # In Developer Tools &gt; Template {{ states.sensor.tibber_home_current_interval_price.last_updated }}   Debug in code:  # Add logging in sensor/core.py _LOGGER.debug(&quot;Updating sensor %s: old=%s new=%s&quot;, self.entity_id, self._attr_native_value, new_value)   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Period Calculation Wrongâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#period-calculation-wrong","content":" Enable detailed period logs:  # coordinator/period_handlers/period_building.py _LOGGER.debug(&quot;Candidate intervals: %s&quot;, [(i['startsAt'], i['total']) for i in candidates])   Check filter statistics:  [period_building] Flex filter blocked: 45 intervals [period_building] Min distance blocked: 12 intervals [period_building] Level filter blocked: 8 intervals   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Performance Profilingâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#performance-profiling","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Time Executionâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#time-execution","content":" import time start = time.perf_counter() result = expensive_function() duration = time.perf_counter() - start _LOGGER.debug(&quot;Function took %.3fs&quot;, duration)   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Memory Usageâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#memory-usage","content":" import tracemalloc tracemalloc.start() # ... your code ... current, peak = tracemalloc.get_traced_memory() _LOGGER.debug(&quot;Memory: current=%d peak=%d&quot;, current, peak) tracemalloc.stop()   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Profile with cProfileâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#profile-with-cprofile","content":" python -m cProfile -o profile.stats -m homeassistant -c config python -m pstats profile.stats # Then: sort cumtime, stats 20   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Live Debugging in Running HAâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#live-debugging-in-running-ha","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Remote Debugging with debugpyâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#remote-debugging-with-debugpy","content":" Add to coordinator code:  import debugpy debugpy.listen(5678) _LOGGER.info(&quot;Waiting for debugger attach on port 5678&quot;) debugpy.wait_for_client()   Connect from VS Code with remote attach configuration.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"IPython REPLâ€‹","type":1,"pageTitle":"Debugging Guide","url":"/hass.tibber_prices/developer/debugging#ipython-repl","content":" Install in container:  uv pip install ipython   Add breakpoint:  from IPython import embed embed() # Drops into interactive shell     ğŸ’¡ Related:  Testing Guide - Writing and running testsSetup Guide - Development environmentArchitecture - Code structure ","version":"Next ğŸš§","tagName":"h3"},{"title":"Developer Documentation","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/intro","content":"","keywords":"","version":"Next ğŸš§"},{"title":"ğŸ“š Developer Guidesâ€‹","type":1,"pageTitle":"Developer Documentation","url":"/hass.tibber_prices/developer/intro#-developer-guides","content":" Setup - DevContainer, environment setup, and dependenciesArchitecture - Code structure, patterns, and conventionsPeriod Calculation Theory - Mathematical foundations, Flex/Distance interaction, Relaxation strategyTimer Architecture - Timer system, scheduling, coordination (3 independent timers)Caching Strategy - Cache layers, invalidation, debuggingTesting - How to run tests and write new test casesRelease Management - Release workflow and versioning processCoding Guidelines - Style guide, linting, and best practicesRefactoring Guide - How to plan and execute major refactorings  ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ¤– AI Documentationâ€‹","type":1,"pageTitle":"Developer Documentation","url":"/hass.tibber_prices/developer/intro#-ai-documentation","content":" The main AI/Copilot documentation is in AGENTS.md. This file serves as long-term memory for AI assistants and contains:  Detailed architectural patternsCode quality rules and conventionsDevelopment workflow guidanceCommon pitfalls and anti-patternsProject-specific patterns and utilities  Important: When proposing changes to patterns or conventions, always update AGENTS.md to keep AI guidance consistent.  ","version":"Next ğŸš§","tagName":"h2"},{"title":"AI-Assisted Developmentâ€‹","type":1,"pageTitle":"Developer Documentation","url":"/hass.tibber_prices/developer/intro#ai-assisted-development","content":" This integration is developed with extensive AI assistance (GitHub Copilot, Claude, and other AI tools). The AI handles:  Pattern Recognition: Understanding and applying Home Assistant best practicesCode Generation: Implementing features with proper type hints, error handling, and documentationRefactoring: Maintaining consistency across the codebase during structural changesTranslation Management: Keeping 5 language files synchronizedDocumentation: Generating and maintaining comprehensive documentation  Quality Assurance:  Automated linting with Ruff (120-char line length, max complexity 25)Home Assistant's type checking and validationReal-world testing in development environmentCode review by maintainer before merging  Benefits:  Rapid feature development while maintaining qualityConsistent code patterns across all modulesComprehensive documentation maintained alongside codeQuick bug fixes with proper understanding of context  Limitations:  AI may occasionally miss edge cases or subtle bugsSome complex Home Assistant patterns may need human reviewTranslation quality depends on AI's understanding of target languageUser feedback is crucial for discovering real-world issues  If you're working with AI tools on this project, the AGENTS.md file provides the context and patterns that ensure consistency.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"ğŸš€ Quick Start for Contributorsâ€‹","type":1,"pageTitle":"Developer Documentation","url":"/hass.tibber_prices/developer/intro#-quick-start-for-contributors","content":" Fork and clone the repositoryOpen in DevContainer (VS Code: &quot;Reopen in Container&quot;)Run setup: ./scripts/setup/setup (happens automatically via postCreateCommand)Start development environment: ./scripts/developMake your changes following the Coding GuidelinesRun linting: ./scripts/lintValidate integration: ./scripts/release/hassfestTest your changes in the running Home Assistant instanceCommit using Conventional Commits formatOpen a Pull Request with clear description  ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ› ï¸ Development Toolsâ€‹","type":1,"pageTitle":"Developer Documentation","url":"/hass.tibber_prices/developer/intro#ï¸-development-tools","content":" The project includes several helper scripts in ./scripts/:  bootstrap - Initial setup of dependenciesdevelop - Start Home Assistant in debug mode (auto-cleans .egg-info)clean - Remove build artifacts and cacheslint - Auto-fix code issues with rufflint-check - Check code without modifications (CI mode)hassfest - Validate integration structure (JSON, Python syntax, required files)setup - Install development tools (git-cliff, @github/copilot)prepare-release - Prepare a new release (bump version, create tag)generate-release-notes - Generate release notes from commits  ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ“¦ Project Structureâ€‹","type":1,"pageTitle":"Developer Documentation","url":"/hass.tibber_prices/developer/intro#-project-structure","content":" custom_components/tibber_prices/ â”œâ”€â”€ __init__.py # Integration setup â”œâ”€â”€ coordinator.py # Data update coordinator with caching â”œâ”€â”€ api.py # Tibber GraphQL API client â”œâ”€â”€ price_utils.py # Price enrichment functions â”œâ”€â”€ average_utils.py # Average calculation utilities â”œâ”€â”€ sensor/ # Sensor platform (package) â”‚ â”œâ”€â”€ __init__.py # Platform setup â”‚ â”œâ”€â”€ core.py # TibberPricesSensor class â”‚ â”œâ”€â”€ definitions.py # Entity descriptions â”‚ â”œâ”€â”€ helpers.py # Pure helper functions â”‚ â””â”€â”€ attributes.py # Attribute builders â”œâ”€â”€ binary_sensor.py # Binary sensor platform â”œâ”€â”€ entity_utils/ # Shared entity helpers â”‚ â”œâ”€â”€ icons.py # Icon mapping logic â”‚ â”œâ”€â”€ colors.py # Color mapping logic â”‚ â””â”€â”€ attributes.py # Common attribute builders â”œâ”€â”€ services.py # Custom services â”œâ”€â”€ config_flow.py # UI configuration flow â”œâ”€â”€ const.py # Constants and helpers â”œâ”€â”€ translations/ # Standard HA translations â””â”€â”€ custom_translations/ # Extended translations (descriptions)   ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ” Key Conceptsâ€‹","type":1,"pageTitle":"Developer Documentation","url":"/hass.tibber_prices/developer/intro#-key-concepts","content":" DataUpdateCoordinator Pattern:  Centralized data fetching and cachingAutomatic entity updates on data changesPersistent storage via StoreQuarter-hour boundary refresh scheduling  Price Data Enrichment:  Raw API data is enriched with statistical analysisTrailing/leading 24h averages calculated per intervalPrice differences and ratings addedAll via pure functions in price_utils.py  Translation System:  Dual system: /translations/ (HA schema) + /custom_translations/ (extended)Both must stay in sync across all languages (de, en, nb, nl, sv)Async loading at integration setup  ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ§ª Testingâ€‹","type":1,"pageTitle":"Developer Documentation","url":"/hass.tibber_prices/developer/intro#-testing","content":" # Validate integration structure ./scripts/release/hassfest # Run all tests pytest tests/ # Run specific test file pytest tests/test_coordinator.py # Run with coverage pytest --cov=custom_components.tibber_prices tests/   ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ“ Documentation Standardsâ€‹","type":1,"pageTitle":"Developer Documentation","url":"/hass.tibber_prices/developer/intro#-documentation-standards","content":" User-facing docs go in docs/user/Developer docs go in docs/development/AI guidance goes in AGENTS.mdUse clear examples and code snippetsKeep docs up-to-date with code changes  ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ¤ Contributingâ€‹","type":1,"pageTitle":"Developer Documentation","url":"/hass.tibber_prices/developer/intro#-contributing","content":" See CONTRIBUTING.md for detailed contribution guidelines, code of conduct, and pull request process.  ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ“„ Licenseâ€‹","type":1,"pageTitle":"Developer Documentation","url":"/hass.tibber_prices/developer/intro#-license","content":" This project is licensed under the Apache License 2.0.    Note: This documentation is for developers. End users should refer to the User Documentation. ","version":"Next ğŸš§","tagName":"h2"},{"title":"Refactoring Guide","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/refactoring-guide","content":"","keywords":"","version":"Next ğŸš§"},{"title":"When to Plan a Refactoringâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#when-to-plan-a-refactoring","content":" Not every code change needs a detailed plan. Create a refactoring plan when:  ğŸ”´ Major changes requiring planning:  Splitting modules into packages (&gt;5 files affected, &gt;500 lines moved)Architectural changes (new packages, module restructuring)Breaking changes (API changes, config format migrations)  ğŸŸ¡ Medium changes that might benefit from planning:  Complex features with multiple moving partsChanges affecting many files (&gt;3 files, unclear best approach)Refactorings with unclear scope  ğŸŸ¢ Small changes - no planning needed:  Bug fixes (straightforward, &lt;100 lines)Small features (&lt;3 files, clear approach)Documentation updatesCosmetic changes (formatting, renaming)  ","version":"Next ğŸš§","tagName":"h2"},{"title":"The Planning Processâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#the-planning-process","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"1. Create a Planning Documentâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#1-create-a-planning-document","content":" Create a file in the planning/ directory (git-ignored for free iteration):  # Example: touch planning/my-feature-refactoring-plan.md   Note: The planning/ directory is git-ignored, so you can iterate freely without polluting git history.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"2. Use the Planning Templateâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#2-use-the-planning-template","content":" Every planning document should include:  # &lt;Feature&gt; Refactoring Plan **Status**: ğŸ”„ PLANNING | ğŸš§ IN PROGRESS | âœ… COMPLETED | âŒ CANCELLED **Created**: YYYY-MM-DD **Last Updated**: YYYY-MM-DD ## Problem Statement - What's the issue? - Why does it need fixing? - Current pain points ## Proposed Solution - High-level approach - File structure (before/after) - Module responsibilities ## Migration Strategy - Phase-by-phase breakdown - File lifecycle (CREATE/MODIFY/DELETE/RENAME) - Dependencies between phases - Testing checkpoints ## Risks &amp; Mitigation - What could go wrong? - How to prevent it? - Rollback strategy ## Success Criteria - Measurable improvements - Testing requirements - Verification steps   See planning/README.md for detailed template explanation.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"3. Iterate Freelyâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#3-iterate-freely","content":" Since planning/ is git-ignored:  Draft multiple versionsGet AI assistance without commit pressureRefine until the plan is solidNo need to clean up intermediate versions  ","version":"Next ğŸš§","tagName":"h3"},{"title":"4. Implementation Phaseâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#4-implementation-phase","content":" Once plan is approved:  Follow the phases defined in the planTest after each phase (don't skip!)Update plan if issues discoveredTrack progress through phase status  ","version":"Next ğŸš§","tagName":"h3"},{"title":"5. After Completionâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#5-after-completion","content":" Option A: Archive in docs/development/If the plan has lasting value (successful pattern, reusable approach):  mv planning/my-feature-refactoring-plan.md docs/development/ git add docs/development/my-feature-refactoring-plan.md git commit -m &quot;docs: archive successful refactoring plan&quot;   Option B: DeleteIf the plan served its purpose and code is the source of truth:  rm planning/my-feature-refactoring-plan.md   Option C: Keep locally (not committed)For &quot;why we didn't do X&quot; reference:  mkdir -p planning/archive mv planning/my-feature-refactoring-plan.md planning/archive/ # Still git-ignored, just organized   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Real-World Exampleâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#real-world-example","content":" The sensor/ package refactoring (Nov 2025) is a successful example:  Before:  sensor.py - 2,574 lines, hard to navigate  After:  sensor/ package with 5 focused modulesEach module &lt;800 linesClear separation of concerns  Process:  Created planning/module-splitting-plan.md (now in docs/development/)Defined 6 phases with clear file lifecycleImplemented phase by phaseTested after each phaseDocumented in AGENTS.mdMoved plan to docs/development/ as reference  Key learnings:  Temporary _impl.py files avoid Python package conflictsTest after EVERY phase (don't accumulate changes)Clear file lifecycle (CREATE/MODIFY/DELETE/RENAME)Phase-by-phase approach enables safe rollback  Note: The complete module splitting plan was documented during implementation but has been superseded by the actual code structure.  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Phase-by-Phase Implementationâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#phase-by-phase-implementation","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Why Phases Matterâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#why-phases-matter","content":" Breaking refactorings into phases:  âœ… Enables testing after each change (catch bugs early)âœ… Allows rollback to last good stateâœ… Makes progress visibleâœ… Reduces cognitive load (focus on one thing)âŒ Takes more time (but worth it!)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Phase Structureâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#phase-structure","content":" Each phase should:  Have clear goal - What's being changed?Document file lifecycle - CREATE/MODIFY/DELETE/RENAMEDefine success criteria - How to verify it worked?Include testing steps - What to test?Estimate time - Realistic time budget  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Example Phase Documentationâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#example-phase-documentation","content":" ### Phase 3: Extract Helper Functions (Session 3) **Goal**: Move pure utility functions to helpers.py **File Lifecycle**: - âœ¨ CREATE `sensor/helpers.py` (utility functions) - âœï¸ MODIFY `sensor/core.py` (import from helpers.py) **Steps**: 1. Create sensor/helpers.py 2. Move pure functions (no state, no self) 3. Add comprehensive docstrings 4. Update imports in core.py **Estimated time**: 45 minutes **Success criteria**: - âœ… All pure functions moved - âœ… `./scripts/lint-check` passes - âœ… HA starts successfully - âœ… All entities work correctly   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Testing Strategyâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#testing-strategy","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"After Each Phaseâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#after-each-phase","content":" Minimum testing checklist:  # 1. Linting passes ./scripts/lint-check # 2. Home Assistant starts ./scripts/develop # Watch for startup errors in logs # 3. Integration loads # Check: Settings â†’ Devices &amp; Services â†’ Tibber Prices # Verify: All entities appear # 4. Basic functionality # Test: Data updates without errors # Check: Entity states update correctly   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Comprehensive Testing (Final Phase)â€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#comprehensive-testing-final-phase","content":" After completing all phases:  Test all entities (sensors, binary sensors)Test configuration flow (add/modify/remove)Test options flow (change settings)Test services (custom service calls)Test error handling (disconnect API, invalid data)Test caching (restart HA, verify cache loads)Test time-based updates (quarter-hour refresh)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Common Pitfallsâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#common-pitfalls","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"âŒ Skip Planning for Large Changesâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#-skip-planning-for-large-changes","content":" Problem: &quot;This seems straightforward, I'll just start coding...&quot;  Result: Halfway through, realize the approach doesn't work. Wasted time.  Solution: If unsure, spend 30 minutes on a rough plan. Better to plan and discard than get stuck.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"âŒ Implement All Phases at Onceâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#-implement-all-phases-at-once","content":" Problem: &quot;I'll do all phases, then test everything...&quot;  Result: 10+ files changed, 2000+ lines modified, hard to debug if something breaks.  Solution: Test after EVERY phase. Commit after each successful phase.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"âŒ Forget to Update Documentationâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#-forget-to-update-documentation","content":" Problem: Code is refactored, but AGENTS.md and docs/ still reference old structure.  Result: AI/humans get confused by outdated documentation.  Solution: Include &quot;Documentation Phase&quot; at the end of every refactoring plan.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"âŒ Ignore the Planning Directoryâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#-ignore-the-planning-directory","content":" Problem: &quot;I'll just create the plan in docs/ directly...&quot;  Result: Git history polluted with draft iterations, or pressure to &quot;commit something&quot; too early.  Solution: Always use planning/ for work-in-progress. Move to docs/ only when done.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Integration with AI Developmentâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#integration-with-ai-development","content":" This project uses AI heavily (GitHub Copilot, Claude). The planning process supports AI development:  AI reads from:  AGENTS.md - Long-term memory, patterns, conventions (AI-focused)docs/development/ - Human-readable guides (human-focused)planning/ - Active refactoring plans (shared context)  AI updates:  AGENTS.md - When patterns changeplanning/*.md - During refactoring implementationdocs/development/ - After successful completion  Why separate AGENTS.md and docs/development/?  AGENTS.md: Technical, comprehensive, AI-optimizeddocs/development/: Practical, focused, human-optimizedBoth stay in sync but serve different audiences  See AGENTS.md section &quot;Planning Major Refactorings&quot; for AI-specific guidance.  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Tools and Resourcesâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#tools-and-resources","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Planning Directoryâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#planning-directory","content":" planning/ - Git-ignored workspace for draftsplanning/README.md - Detailed planning documentationplanning/*.md - Active refactoring plans  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Example Plansâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#example-plans","content":" docs/development/module-splitting-plan.md - âœ… Completed, archivedplanning/config-flow-refactoring-plan.md - ğŸ”„ Planned (1013 lines â†’ 4 modules)planning/binary-sensor-refactoring-plan.md - ğŸ”„ Planned (644 lines â†’ 4 modules)planning/coordinator-refactoring-plan.md - ğŸ”„ Planned (1446 lines, high complexity)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Helper Scriptsâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#helper-scripts","content":" ./scripts/lint-check # Verify code quality ./scripts/develop # Start HA for testing ./scripts/lint # Auto-fix issues   ","version":"Next ğŸš§","tagName":"h3"},{"title":"FAQâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#faq","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Q: When should I create a plan vs. just start coding?â€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#q-when-should-i-create-a-plan-vs-just-start-coding","content":" A: If you're asking this question, you probably need a plan. ğŸ˜Š  Simple rule: If you can't describe the entire change in 3 sentences, create a plan.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Q: How detailed should the plan be?â€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#q-how-detailed-should-the-plan-be","content":" A: Detailed enough to execute without major surprises, but not a line-by-line script.  Good plan level:  Lists all files affected (CREATE/MODIFY/DELETE)Defines phases with clear boundariesIncludes testing strategyEstimates time per phase  Too detailed:  Exact code snippets for every changeLine-by-line instructions  Too vague:  &quot;Refactor sensor.py to be better&quot;No phase breakdownNo testing strategy  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Q: What if the plan changes during implementation?â€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#q-what-if-the-plan-changes-during-implementation","content":" A: Update the plan! Planning documents are living documents.  If you discover:  Better approach â†’ Update &quot;Proposed Solution&quot;More phases needed â†’ Add to &quot;Migration Strategy&quot;New risks â†’ Update &quot;Risks &amp; Mitigation&quot;  Document WHY the plan changed (helps future refactorings).  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Q: Should every refactoring follow this process?â€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#q-should-every-refactoring-follow-this-process","content":" A: No! Use judgment:  Small changes (&lt;100 lines, clear approach): Just do it, no plan neededMedium changes (unclear scope): Write rough outline, refine if neededLarge changes (&gt;500 lines, &gt;5 files): Full planning process  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Q: How do I know when a refactoring is successful?â€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#q-how-do-i-know-when-a-refactoring-is-successful","content":" A: Check the &quot;Success Criteria&quot; from your plan:  Typical criteria:  âœ… All linting checks passâœ… HA starts without errorsâœ… All entities functionalâœ… No regressions (existing features work)âœ… Code easier to understand/modifyâœ… Documentation updated  If you can't tick all boxes, the refactoring isn't done.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Summaryâ€‹","type":1,"pageTitle":"Refactoring Guide","url":"/hass.tibber_prices/developer/refactoring-guide#summary","content":" Key takeaways:  Plan when scope is unclear (&gt;500 lines, &gt;5 files, breaking changes)Use planning/ directory for free iteration (git-ignored)Work in phases and test after each phaseDocument file lifecycle (CREATE/MODIFY/DELETE/RENAME)Update documentation after completion (AGENTS.md, docs/)Archive or delete plan after implementation  Remember: Good planning prevents half-finished refactorings and makes rollback easier when things go wrong.    Next steps:  Read planning/README.md for detailed templateCheck docs/development/module-splitting-plan.md for real exampleBrowse planning/ for active refactoring plans ","version":"Next ğŸš§","tagName":"h2"},{"title":"Release Notes Generation","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/release-management","content":"","keywords":"","version":"Next ğŸš§"},{"title":"ğŸš€ Quick Start: Preparing a Releaseâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#-quick-start-preparing-a-release","content":" Recommended workflow (automatic &amp; foolproof):  # 1. Use the helper script to prepare release ./scripts/release/prepare 0.3.0 # This will: # - Update manifest.json version to 0.3.0 # - Create commit: &quot;chore(release): bump version to 0.3.0&quot; # - Create tag: v0.3.0 # - Show you what will be pushed # 2. Review and push when ready git push origin main v0.3.0 # 3. CI/CD automatically: # - Detects the new tag # - Generates release notes (excluding version bump commit) # - Creates GitHub release   If you forget to bump manifest.json:  # Just edit manifest.json manually and commit vim custom_components/tibber_prices/manifest.json # &quot;version&quot;: &quot;0.3.0&quot; git commit -am &quot;chore(release): bump version to 0.3.0&quot; git push # Auto-Tag workflow detects manifest.json change and creates tag automatically! # Then Release workflow kicks in and creates the GitHub release     ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ“‹ Release Optionsâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#-release-options","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"1. GitHub UI Button (Easiest)â€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#1-github-ui-button-easiest","content":" Use GitHub's built-in release notes generator:  Go to ReleasesClick &quot;Draft a new release&quot;Select your tagClick &quot;Generate release notes&quot; buttonEdit if needed and publish  Uses: .github/release.yml configurationBest for: Quick releases, works with PRs that have labelsNote: Direct commits appear in &quot;Other Changes&quot; category    ","version":"Next ğŸš§","tagName":"h3"},{"title":"2. Local Script (Intelligent)â€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#2-local-script-intelligent","content":" Run ./scripts/release/generate-notes to parse conventional commits locally.  Automatic backend detection:  # Generate from latest tag to HEAD ./scripts/release/generate-notes # Generate between specific tags ./scripts/release/generate-notes v1.0.0 v1.1.0 # Generate from tag to HEAD ./scripts/release/generate-notes v1.0.0 HEAD   Force specific backend:  # Use AI (GitHub Copilot CLI) RELEASE_NOTES_BACKEND=copilot ./scripts/release/generate-notes # Use git-cliff (template-based) RELEASE_NOTES_BACKEND=git-cliff ./scripts/release/generate-notes # Use manual parsing (grep/awk fallback) RELEASE_NOTES_BACKEND=manual ./scripts/release/generate-notes   Disable AI (useful for CI/CD):  USE_AI=false ./scripts/release/generate-notes   Backend Priorityâ€‹  The script automatically selects the best available backend:  GitHub Copilot CLI - AI-powered, context-aware (best quality)git-cliff - Fast Rust tool with templates (reliable)Manual - Simple grep/awk parsing (always works)  In CI/CD ($CI or $GITHUB_ACTIONS), AI is automatically disabled.  Installing Optional Backendsâ€‹  In DevContainer (automatic):  git-cliff is automatically installed when the DevContainer is built:  Rust toolchain: Installed via ghcr.io/devcontainers/features/rust:1 (minimal profile)git-cliff: Installed via cargo in scripts/setup/setup  Simply rebuild the container (VS Code: &quot;Dev Containers: Rebuild Container&quot;) and git-cliff will be available.  Manual installation (outside DevContainer):  git-cliff (template-based):  # See: https://git-cliff.org/docs/installation # macOS brew install git-cliff # Cargo (all platforms) cargo install git-cliff # Manual binary download wget https://github.com/orhun/git-cliff/releases/latest/download/git-cliff-x86_64-unknown-linux-gnu.tar.gz tar -xzf git-cliff-*.tar.gz sudo mv git-cliff-*/git-cliff /usr/local/bin/     ","version":"Next ğŸš§","tagName":"h3"},{"title":"3. CI/CD Automationâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#3-cicd-automation","content":" Automatic release notes on tag push.  Workflow: .github/workflows/release.yml  Triggers: Version tags (v1.0.0, v2.1.3, etc.)  # Create and push a tag to trigger automatic release git tag v1.0.0 git push origin v1.0.0 # GitHub Actions will: # 1. Detect the new tag # 2. Generate release notes using git-cliff # 3. Create a GitHub release automatically   Backend: Uses git-cliff (AI disabled in CI for reliability)    ","version":"Next ğŸš§","tagName":"h3"},{"title":"ğŸ“ Output Formatâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#-output-format","content":" All methods produce GitHub-flavored Markdown with emoji categories:  ## ğŸ‰ New Features - **scope**: Description ([abc1234](link-to-commit)) ## ğŸ› Bug Fixes - **scope**: Description ([def5678](link-to-commit)) ## ğŸ“š Documentation - **scope**: Description ([ghi9012](link-to-commit)) ## ğŸ”§ Maintenance &amp; Refactoring - **scope**: Description ([jkl3456](link-to-commit)) ## ğŸ§ª Testing - **scope**: Description ([mno7890](link-to-commit))     ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ¯ When to Use Whichâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#-when-to-use-which","content":" Method\tUse Case\tPros\tConsHelper Script\tNormal releases\tFoolproof, automatic\tRequires script Auto-Tag Workflow\tForgot script\tSafety net, automatic tagging\tStill need manifest bump GitHub Button\tManual quick release\tEasy, no script\tLimited categorization Local Script\tTesting release notes\tPreview before release\tManual process CI/CD\tAfter tag push\tFully automatic\tNeeds tag first    ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ”„ Complete Release Workflowsâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#-complete-release-workflows","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Workflow A: Using Helper Script (Recommended)â€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#workflow-a-using-helper-script-recommended","content":" # Step 1: Prepare release (all-in-one) ./scripts/release/prepare 0.3.0 # Step 2: Review changes git log -1 --stat git show v0.3.0 # Step 3: Push when ready git push origin main v0.3.0 # Done! CI/CD creates the release automatically   What happens:  Script bumps manifest.json â†’ commits â†’ creates tag locallyYou push commit + tag togetherRelease workflow sees tag â†’ generates notes â†’ creates release    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Workflow B: Manual (with Auto-Tag Safety Net)â€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#workflow-b-manual-with-auto-tag-safety-net","content":" # Step 1: Bump version manually vim custom_components/tibber_prices/manifest.json # Change: &quot;version&quot;: &quot;0.3.0&quot; # Step 2: Commit git commit -am &quot;chore(release): bump version to 0.3.0&quot; git push # Step 3: Wait for Auto-Tag workflow # GitHub Actions automatically creates v0.3.0 tag # Then Release workflow creates the release   What happens:  You push manifest.json changeAuto-Tag workflow detects change â†’ creates tag automaticallyRelease workflow sees new tag â†’ creates release    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Workflow C: Manual Tag (Old Way)â€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#workflow-c-manual-tag-old-way","content":" # Step 1: Bump version vim custom_components/tibber_prices/manifest.json git commit -am &quot;chore(release): bump version to 0.3.0&quot; # Step 2: Create tag manually git tag v0.3.0 git push origin main v0.3.0 # Release workflow creates release   What happens:  You create and push tag manuallyRelease workflow creates releaseAuto-Tag workflow skips (tag already exists)    ","version":"Next ğŸš§","tagName":"h3"},{"title":"âš™ï¸ Configuration Filesâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#ï¸-configuration-files","content":" scripts/release/prepare - Helper script to bump version + create tag.github/workflows/auto-tag.yml - Automatic tag creation on manifest.json change.github/workflows/release.yml - Automatic release on tag push.github/release.yml - GitHub UI button configurationcliff.toml - git-cliff template (filters out version bumps)    ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ›¡ï¸ Safety Featuresâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#ï¸-safety-features","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"1. Version Validationâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#1-version-validation","content":" Both helper script and auto-tag workflow validate version format (X.Y.Z).  ","version":"Next ğŸš§","tagName":"h3"},{"title":"2. No Duplicate Tagsâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#2-no-duplicate-tags","content":" Helper script checks if tag exists (local + remote)Auto-tag workflow checks if tag exists before creating  ","version":"Next ğŸš§","tagName":"h3"},{"title":"3. Atomic Operationsâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#3-atomic-operations","content":" Helper script creates commit + tag locally. You decide when to push.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"4. Version Bumps Filteredâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#4-version-bumps-filtered","content":" Release notes automatically exclude chore(release): bump version commits.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"5. Rollback Instructionsâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#5-rollback-instructions","content":" Helper script shows how to undo if you change your mind.    ","version":"Next ğŸš§","tagName":"h3"},{"title":"ğŸ› Troubleshootingâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#-troubleshooting","content":" &quot;Tag already exists&quot; error:  # Local tag git tag -d v0.3.0 # Remote tag (only if you need to recreate) git push origin :refs/tags/v0.3.0   Manifest version doesn't match tag:  This shouldn't happen with the new workflows, but if it does:  # 1. Fix manifest.json vim custom_components/tibber_prices/manifest.json # 2. Amend the commit git commit --amend -am &quot;chore(release): bump version to 0.3.0&quot; # 3. Move the tag git tag -f v0.3.0 git push -f origin main v0.3.0   Auto-tag didn't create tag:  Check workflow runs in GitHub Actions. Common causes:  Tag already exists remotelyInvalid version format in manifest.jsonmanifest.json not in the commit that was pushed    ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ” Format Requirementsâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#-format-requirements","content":" HACS: No specific format required, uses GitHub releases as-isHome Assistant: No specific format required for custom integrationsMarkdown: Standard GitHub-flavored Markdown supportedHTML: Can include &lt;ha-alert&gt; tags if needed    ","version":"Next ğŸš§","tagName":"h2"},{"title":"ğŸ’¡ Tipsâ€‹","type":1,"pageTitle":"Release Notes Generation","url":"/hass.tibber_prices/developer/release-management#-tips","content":" Conventional Commits: Use proper commit format for best results: feat(scope): Add new feature Detailed description of what changed. Impact: Users can now do X and Y. Impact Section: Add Impact: in commit body for user-friendly descriptions Test Locally: Run ./scripts/release/generate-notes before creating release AI vs Template: GitHub Copilot CLI provides better descriptions, git-cliff is faster and more reliable CI/CD: Tag push triggers automatic release - no manual intervention needed ","version":"Next ğŸš§","tagName":"h2"},{"title":"Performance Optimization","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/performance","content":"","keywords":"","version":"Next ğŸš§"},{"title":"Performance Goalsâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#performance-goals","content":" Target metrics:  Coordinator update: &lt;500ms (typical: 200-300ms)Sensor update: &lt;10ms per sensorPeriod calculation: &lt;100ms (typical: 20-50ms)Memory footprint: &lt;10MB per homeAPI calls: &lt;100 per day per home  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Profilingâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#profiling","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Timing Decoratorâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#timing-decorator","content":" Use for performance-critical functions:  import time import functools def timing(func): @functools.wraps(func) def wrapper(*args, **kwargs): start = time.perf_counter() result = func(*args, **kwargs) duration = time.perf_counter() - start _LOGGER.debug(&quot;%s took %.3fms&quot;, func.__name__, duration * 1000) return result return wrapper @timing def expensive_calculation(): # Your code here   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Memory Profilingâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#memory-profiling","content":" import tracemalloc tracemalloc.start() # Run your code current, peak = tracemalloc.get_traced_memory() _LOGGER.info(&quot;Memory: current=%.2fMB peak=%.2fMB&quot;, current / 1024**2, peak / 1024**2) tracemalloc.stop()   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Async Profilingâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#async-profiling","content":" # Install aioprof uv pip install aioprof # Run with profiling python -m aioprof homeassistant -c config   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Optimization Patternsâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#optimization-patterns","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Cachingâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#caching","content":" 1. Persistent Cache (API data):  # Already implemented in coordinator/cache.py store = Store(hass, STORAGE_VERSION, STORAGE_KEY) data = await store.async_load()   2. Translation Cache (in-memory):  # Already implemented in const.py _TRANSLATION_CACHE: dict[str, dict] = {} def get_translation(path: str, language: str) -&gt; dict: cache_key = f&quot;{path}_{language}&quot; if cache_key not in _TRANSLATION_CACHE: _TRANSLATION_CACHE[cache_key] = load_translation(path, language) return _TRANSLATION_CACHE[cache_key]   3. Config Cache (invalidated on options change):  class DataTransformer: def __init__(self): self._config_cache: dict | None = None def get_config(self) -&gt; dict: if self._config_cache is None: self._config_cache = self._build_config() return self._config_cache def invalidate_config_cache(self): self._config_cache = None   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Lazy Loadingâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#lazy-loading","content":" Load data only when needed:  @property def extra_state_attributes(self) -&gt; dict | None: &quot;&quot;&quot;Return attributes.&quot;&quot;&quot; # Calculate only when accessed if self.entity_description.key == &quot;complex_sensor&quot;: return self._calculate_complex_attributes() return None   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Bulk Operationsâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#bulk-operations","content":" Process multiple items at once:  # âŒ Slow - loop with individual operations for interval in intervals: enriched = enrich_single_interval(interval) results.append(enriched) # âœ… Fast - bulk processing results = enrich_intervals_bulk(intervals)   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Async Best Practicesâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#async-best-practices","content":" 1. Concurrent API calls:  # âŒ Sequential (slow) user_data = await fetch_user_data() price_data = await fetch_price_data() # âœ… Concurrent (fast) user_data, price_data = await asyncio.gather( fetch_user_data(), fetch_price_data() )   2. Don't block event loop:  # âŒ Blocking result = heavy_computation() # Blocks for seconds # âœ… Non-blocking result = await hass.async_add_executor_job(heavy_computation)   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Memory Managementâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#memory-management","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Avoid Memory Leaksâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#avoid-memory-leaks","content":" 1. Clear references:  class Coordinator: async def async_shutdown(self): &quot;&quot;&quot;Clean up resources.&quot;&quot;&quot; self._listeners.clear() self._data = None self._cache = None   2. Use weak references for callbacks:  import weakref class Manager: def __init__(self): self._callbacks: list[weakref.ref] = [] def register(self, callback): self._callbacks.append(weakref.ref(callback))   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Efficient Data Structuresâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#efficient-data-structures","content":" Use appropriate types:  # âŒ List for lookups (O(n)) if timestamp in timestamp_list: ... # âœ… Set for lookups (O(1)) if timestamp in timestamp_set: ... # âŒ List comprehension with filter results = [x for x in items if condition(x)] # âœ… Generator for large datasets results = (x for x in items if condition(x))   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Coordinator Optimizationâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#coordinator-optimization","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Minimize API Callsâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#minimize-api-calls","content":" Already implemented:  Cache valid until midnightUser data cached for 24hOnly poll when tomorrow data expected  Monitor API usage:  _LOGGER.debug(&quot;API call: %s (cache_age=%s)&quot;, endpoint, cache_age)   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Smart Updatesâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#smart-updates","content":" Only update when needed:  async def _async_update_data(self) -&gt; dict: &quot;&quot;&quot;Fetch data from API.&quot;&quot;&quot; if self._is_cache_valid(): _LOGGER.debug(&quot;Using cached data&quot;) return self.data # Fetch new data return await self._fetch_data()   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Database Impactâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#database-impact","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"State Class Selectionâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#state-class-selection","content":" Affects long-term statistics storage:  # âŒ MEASUREMENT for prices (stores every change) state_class=SensorStateClass.MEASUREMENT # ~35K records/year # âœ… None for prices (no long-term stats) state_class=None # Only current state # âœ… TOTAL for counters only state_class=SensorStateClass.TOTAL # For cumulative values   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Attribute Sizeâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#attribute-size","content":" Keep attributes minimal:  # âŒ Large nested structures (KB per update) attributes = { &quot;all_intervals&quot;: [...], # 384 intervals &quot;full_history&quot;: [...], # Days of data } # âœ… Essential data only (bytes per update) attributes = { &quot;timestamp&quot;: &quot;...&quot;, &quot;rating_level&quot;: &quot;...&quot;, &quot;next_interval&quot;: &quot;...&quot;, }   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Testing Performanceâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#testing-performance","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Benchmark Testsâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#benchmark-tests","content":" import pytest import time @pytest.mark.benchmark def test_period_calculation_performance(coordinator): &quot;&quot;&quot;Period calculation should complete in &amp;lt;100ms.&quot;&quot;&quot; start = time.perf_counter() periods = calculate_periods(coordinator.data) duration = time.perf_counter() - start assert duration &lt; 0.1, f&quot;Too slow: {duration:.3f}s&quot;   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Load Testingâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#load-testing","content":" @pytest.mark.integration async def test_multiple_homes_performance(hass): &quot;&quot;&quot;Test with 10 homes.&quot;&quot;&quot; coordinators = [] for i in range(10): coordinator = create_coordinator(hass, home_id=f&quot;home_{i}&quot;) await coordinator.async_refresh() coordinators.append(coordinator) # Verify memory usage # Verify update times   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Monitoring in Productionâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#monitoring-in-production","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Log Performance Metricsâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#log-performance-metrics","content":" @timing async def _async_update_data(self) -&gt; dict: &quot;&quot;&quot;Fetch data with timing.&quot;&quot;&quot; result = await self._fetch_data() _LOGGER.info(&quot;Update completed in %.2fs&quot;, timing_duration) return result   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Memory Trackingâ€‹","type":1,"pageTitle":"Performance Optimization","url":"/hass.tibber_prices/developer/performance#memory-tracking","content":" import psutil import os process = psutil.Process(os.getpid()) memory_mb = process.memory_info().rss / 1024**2 _LOGGER.debug(&quot;Current memory usage: %.2f MB&quot;, memory_mb)     ğŸ’¡ Related:  Caching Strategy - Cache layersArchitecture - System designDebugging - Profiling tools ","version":"Next ğŸš§","tagName":"h3"},{"title":"Testing","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/testing","content":"","keywords":"","version":"Next ğŸš§"},{"title":"Integration Validationâ€‹","type":1,"pageTitle":"Testing","url":"/hass.tibber_prices/developer/testing#integration-validation","content":" Before running tests or committing changes, validate the integration structure:  # Run local validation (JSON syntax, Python syntax, required files) ./scripts/release/hassfest   This lightweight script checks:  âœ“ config_flow.py existsâœ“ manifest.json is valid JSON with required fieldsâœ“ Translation files have valid JSON syntaxâœ“ All Python files compile without syntax errors  Note: Full hassfest validation runs in GitHub Actions on push.  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Running Testsâ€‹","type":1,"pageTitle":"Testing","url":"/hass.tibber_prices/developer/testing#running-tests","content":" # Run all tests pytest tests/ # Run specific test file pytest tests/test_coordinator.py # Run with coverage pytest --cov=custom_components.tibber_prices tests/   ","version":"Next ğŸš§","tagName":"h2"},{"title":"Manual Testingâ€‹","type":1,"pageTitle":"Testing","url":"/hass.tibber_prices/developer/testing#manual-testing","content":" # Start development environment ./scripts/develop   Then test in Home Assistant UI:  Configuration flowSensor states and attributesServicesTranslation strings  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Test Guidelinesâ€‹","type":1,"pageTitle":"Testing","url":"/hass.tibber_prices/developer/testing#test-guidelines","content":" Coming soon... ","version":"Next ğŸš§","tagName":"h2"},{"title":"Development Setup","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/setup","content":"","keywords":"","version":"Next ğŸš§"},{"title":"Prerequisitesâ€‹","type":1,"pageTitle":"Development Setup","url":"/hass.tibber_prices/developer/setup#prerequisites","content":" VS Code with Dev Container supportDocker installed and runningGitHub account (for Tibber API token)  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Quick Setupâ€‹","type":1,"pageTitle":"Development Setup","url":"/hass.tibber_prices/developer/setup#quick-setup","content":" # Clone the repository git clone https://github.com/jpawlowski/hass.tibber_prices.git cd hass.tibber_prices # Open in VS Code code . # Reopen in DevContainer (VS Code will prompt) # Or manually: Ctrl+Shift+P â†’ &quot;Dev Containers: Reopen in Container&quot;   ","version":"Next ğŸš§","tagName":"h2"},{"title":"Development Environmentâ€‹","type":1,"pageTitle":"Development Setup","url":"/hass.tibber_prices/developer/setup#development-environment","content":" The DevContainer includes:  Python 3.13 with .venv at /home/vscode/.venv/uv package manager (fast, modern Python tooling)Home Assistant development dependenciesRuff linter/formatterGit, GitHub CLI, Node.js, Rust toolchain  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Running the Integrationâ€‹","type":1,"pageTitle":"Development Setup","url":"/hass.tibber_prices/developer/setup#running-the-integration","content":" # Start Home Assistant in debug mode ./scripts/develop   Visit http://localhost:8123  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Making Changesâ€‹","type":1,"pageTitle":"Development Setup","url":"/hass.tibber_prices/developer/setup#making-changes","content":" # Lint and format code ./scripts/lint # Check-only (CI mode) ./scripts/lint-check # Validate integration structure ./scripts/release/hassfest   See AGENTS.md for detailed patterns and conventions. ","version":"Next ğŸš§","tagName":"h2"},{"title":"Period Calculation Theory","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/period-calculation-theory","content":"","keywords":"","version":"Next ğŸš§"},{"title":"Overviewâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#overview","content":" This document explains the mathematical foundations and design decisions behind the period calculation algorithm, particularly focusing on the interaction between Flexibility (Flex), Minimum Distance from Average, and Relaxation Strategy.  Target Audience: Developers maintaining or extending the period calculation logic.  Related Files:  coordinator/period_handlers/core.py - Main calculation entry pointcoordinator/period_handlers/level_filtering.py - Flex and distance filteringcoordinator/period_handlers/relaxation.py - Multi-phase relaxation strategycoordinator/periods.py - Period calculator orchestration    ","version":"Next ğŸš§","tagName":"h2"},{"title":"Core Filtering Criteriaâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#core-filtering-criteria","content":" Period detection uses three independent filters (all must pass):  ","version":"Next ğŸš§","tagName":"h2"},{"title":"1. Flex Filter (Price Distance from Reference)â€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#1-flex-filter-price-distance-from-reference","content":" Purpose: Limit how far prices can deviate from the daily min/max.  Logic:  # Best Price: Price must be within flex% ABOVE daily minimum in_flex = price &lt;= (daily_min + daily_min Ã— flex) # Peak Price: Price must be within flex% BELOW daily maximum in_flex = price &gt;= (daily_max - daily_max Ã— flex)   Example (Best Price):  Daily Min: 10 ct/kWhFlex: 15%Acceptance Range: 0 - 11.5 ct/kWh (10 + 10Ã—0.15)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"2. Min Distance Filter (Distance from Daily Average)â€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#2-min-distance-filter-distance-from-daily-average","content":" Purpose: Ensure periods are significantly cheaper/more expensive than average, not just marginally better.  Logic:  # Best Price: Price must be at least min_distance% BELOW daily average meets_distance = price &lt;= (daily_avg Ã— (1 - min_distance/100)) # Peak Price: Price must be at least min_distance% ABOVE daily average meets_distance = price &gt;= (daily_avg Ã— (1 + min_distance/100))   Example (Best Price):  Daily Avg: 15 ct/kWhMin Distance: 5%Acceptance Range: 0 - 14.25 ct/kWh (15 Ã— 0.95)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"3. Level Filter (Price Level Classification)â€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#3-level-filter-price-level-classification","content":" Purpose: Restrict periods to specific price classifications (VERY_CHEAP, CHEAP, NORMAL, EXPENSIVE, VERY_EXPENSIVE).  Logic: See level_filtering.py for gap tolerance details.  Volatility Thresholds - Important Separation:  The integration maintains two independent sets of volatility thresholds:  Sensor Thresholds (user-configurable via CONF_VOLATILITY_*_THRESHOLD) Purpose: Display classification in sensor.tibber_home_volatility_*Default: LOW &lt; 10%, MEDIUM &lt; 20%, HIGH â‰¥ 20%User can adjust in config flow optionsAffects: Sensor state/attributes only Period Filter Thresholds (internal, fixed) Purpose: Level filter criteria when using level=&quot;volatility_low&quot; etc.Source: PRICE_LEVEL_THRESHOLDS in const.pyValues: Same as sensor defaults (LOW &lt; 10%, MEDIUM &lt; 20%, HIGH â‰¥ 20%)User cannot adjust theseAffects: Period candidate selection  Rationale for Separation:  Sensor thresholds = Display preference (&quot;I want to see LOW at 15% instead of 10%&quot;)Period thresholds = Algorithm configuration (tested defaults, complex interactions)Changing sensor display should not affect automation behaviorPrevents unexpected side effects when user adjusts sensor classificationPeriod calculation has many interacting filters (Flex, Distance, Level) - exposing all internals would be error-prone  Implementation:  # Sensor classification uses user config user_low_threshold = config_entry.options.get(CONF_VOLATILITY_LOW_THRESHOLD, 10) # Period filter uses fixed constants period_low_threshold = PRICE_LEVEL_THRESHOLDS[&quot;volatility_low&quot;] # Always 10%   Status: Intentional design decision (Nov 2025). No plans to expose period thresholds to users.    ","version":"Next ğŸš§","tagName":"h3"},{"title":"The Flex Ã— Min_Distance Conflictâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#the-flex--min_distance-conflict","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Problem Statementâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#problem-statement","content":" These two filters can conflict when Flex is high!  Scenario: Best Price with Flex=50%, Min_Distance=5%â€‹  Given:  Daily Min: 10 ct/kWhDaily Avg: 15 ct/kWhDaily Max: 20 ct/kWh  Flex Filter (50%):  Max accepted = 10 + (10 Ã— 0.50) = 15 ct/kWh   Min Distance Filter (5%):  Max accepted = 15 Ã— (1 - 0.05) = 14.25 ct/kWh   Conflict:  Interval at 14.8 ct/kWh: âœ… Flex: 14.8 â‰¤ 15 (PASS)âŒ Distance: 14.8 &gt; 14.25 (FAIL)Result: Rejected by Min_Distance even though Flex allows it!  The Issue: At high Flex values, Min_Distance becomes the dominant filter and blocks intervals that Flex would permit. This defeats the purpose of having high Flex.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Mathematical Analysisâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#mathematical-analysis","content":" Conflict condition for Best Price:  daily_min Ã— (1 + flex) &gt; daily_avg Ã— (1 - min_distance/100)   Typical values:  Min = 10, Avg = 15, Min_Distance = 5%Conflict occurs when: 10 Ã— (1 + flex) &gt; 14.25Simplify: flex &gt; 0.425 (42.5%)  Below 42.5% Flex: Both filters contribute meaningfully.Above 42.5% Flex: Min_Distance dominates and blocks intervals.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Solution: Dynamic Min_Distance Scalingâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#solution-dynamic-min_distance-scaling","content":" Approach: Reduce Min_Distance proportionally as Flex increases.  Formula:  if flex &gt; 0.20: # 20% threshold flex_excess = flex - 0.20 scale_factor = max(0.25, 1.0 - (flex_excess Ã— 2.5)) adjusted_min_distance = original_min_distance Ã— scale_factor   Scaling Table (Original Min_Distance = 5%):  Flex\tScale Factor\tAdjusted Min_Distance\tRationaleâ‰¤20%\t1.00\t5.0%\tStandard - both filters relevant 25%\t0.88\t4.4%\tSlight reduction 30%\t0.75\t3.75%\tModerate reduction 40%\t0.50\t2.5%\tStrong reduction - Flex dominates 50%\t0.25\t1.25%\tMinimal distance - Flex decides  Why stop at 25% of original?  Min_Distance ensures periods are significantly different from averageEven at 1.25%, prevents &quot;flat days&quot; (little price variation) from accepting every intervalMaintains semantic meaning: &quot;this is a meaningful best/peak price period&quot;  Implementation: See level_filtering.py â†’ check_interval_criteria()  Code Extract:  # coordinator/period_handlers/level_filtering.py FLEX_SCALING_THRESHOLD = 0.20 # 20% - start adjusting min_distance SCALE_FACTOR_WARNING_THRESHOLD = 0.8 # Log when reduction &gt; 20% def check_interval_criteria(price, criteria): # ... flex check ... # Dynamic min_distance scaling adjusted_min_distance = criteria.min_distance_from_avg flex_abs = abs(criteria.flex) if flex_abs &gt; FLEX_SCALING_THRESHOLD: flex_excess = flex_abs - 0.20 # How much above 20% scale_factor = max(0.25, 1.0 - (flex_excess Ã— 2.5)) adjusted_min_distance = criteria.min_distance_from_avg Ã— scale_factor if scale_factor &lt; SCALE_FACTOR_WARNING_THRESHOLD: _LOGGER.debug( &quot;High flex %.1f%% detected: Reducing min_distance %.1f%% â†’ %.1f%%&quot;, flex_abs Ã— 100, criteria.min_distance_from_avg, adjusted_min_distance, ) # Apply adjusted min_distance in distance check meets_min_distance = ( price &lt;= avg_price Ã— (1 - adjusted_min_distance/100) # Best Price # OR price &gt;= avg_price Ã— (1 + adjusted_min_distance/100) # Peak Price )   Why Linear Scaling?  Simple and predictableNo abrupt behavior changesEasy to reason about for users and developersAlternative considered: Exponential scaling (rejected as too aggressive)  Why 25% Minimum?  Below this, min_distance loses semantic meaningEven on flat days, some quality filter neededPrevents &quot;every interval is a period&quot; scenarioMaintains user expectation: &quot;best/peak price means notably different&quot;    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Flex Limits and Safety Capsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#flex-limits-and-safety-caps","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Implementation Constantsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#implementation-constants","content":" Defined in coordinator/period_handlers/core.py:  MAX_SAFE_FLEX = 0.50 # 50% - hard cap: above this, period detection becomes unreliable MAX_OUTLIER_FLEX = 0.25 # 25% - cap for outlier filtering: above this, spike detection too permissive   Defined in const.py:  DEFAULT_BEST_PRICE_FLEX = 15 # 15% base - optimal for relaxation mode (default enabled) DEFAULT_PEAK_PRICE_FLEX = -20 # 20% base (negative for peak detection) DEFAULT_RELAXATION_ATTEMPTS_BEST = 11 # 11 steps: 15% â†’ 48% (3% increment per step) DEFAULT_RELAXATION_ATTEMPTS_PEAK = 11 # 11 steps: 20% â†’ 50% (3% increment per step) DEFAULT_BEST_PRICE_MIN_PERIOD_LENGTH = 60 # 60 minutes DEFAULT_PEAK_PRICE_MIN_PERIOD_LENGTH = 30 # 30 minutes DEFAULT_BEST_PRICE_MIN_DISTANCE_FROM_AVG = 5 # 5% minimum distance DEFAULT_PEAK_PRICE_MIN_DISTANCE_FROM_AVG = 5 # 5% minimum distance   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Rationale for Asymmetric Defaultsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#rationale-for-asymmetric-defaults","content":" Why Best Price â‰  Peak Price?  The different defaults reflect fundamentally different use cases:  Best Price: Optimization Focusâ€‹  Goal: Find practical time windows for running appliances  Constraints:  Appliances need time to complete cycles (dishwasher: 2-3h, EV charging: 4-8h)Short periods are impractical (not worth automation overhead)User wants genuinely cheap times, not just &quot;slightly below average&quot;  Defaults:  60 min minimum - Ensures period is long enough for meaningful use15% flex - Stricter selection, focuses on truly cheap timesReasoning: Better to find fewer, higher-quality periods than many mediocre ones  User behavior:  Automations trigger actions (turn on devices)Wrong automation = wasted energy/moneyPreference: Conservative (miss some savings) over aggressive (false positives)  Peak Price: Warning Focusâ€‹  Goal: Alert users to expensive periods for consumption reduction  Constraints:  Brief price spikes still matter (even 15-30 min is worth avoiding)Early warning more valuable than perfect accuracyUser can manually decide whether to react  Defaults:  30 min minimum - Catches shorter expensive spikes20% flex - More permissive, earlier detectionReasoning: Better to warn early (even if not peak) than miss expensive periods  User behavior:  Notifications/alerts (informational)Wrong alert = minor inconvenience, not costPreference: Sensitive (catch more) over specific (catch only extremes)  Mathematical Justificationâ€‹  Peak Price Volatility:  Price curves tend to have:  Sharp spikes during peak hours (morning/evening)Shorter duration at maximum (1-2 hours typical)Higher variance in peak times than cheap times  Example day:  Cheap period: 02:00-07:00 (5 hours at 10-12 ct) â† Gradual, stable Expensive period: 17:00-18:30 (1.5 hours at 35-40 ct) â† Sharp, brief   Implication:  Stricter flex on peak (15%) might miss real expensive periods (too brief)Longer min_length (60 min) might exclude legitimate spikesSolution: More flexible thresholds for peak detection  Design Alternatives Consideredâ€‹  Option 1: Symmetric defaults (rejected)  Both 60 min, both 15% flexProblem: Misses short but expensive spikesUser feedback: &quot;Why didn't I get warned about the 30-min price spike?&quot;  Option 2: Same defaults, let users figure it out (rejected)  No guidance on best practicesUsers would need to experiment to find good valuesMost users stick with defaults, so defaults matter  Option 3: Current approach (adopted)  All values user-configurable via config flow optionsDifferent installation defaults for Best Price vs. Peak PriceDefaults reflect recommended practices for each use caseUsers who need different behavior can adjustMost users benefit from sensible defaults without configuration    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Flex Limits and Safety Capsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#flex-limits-and-safety-caps-1","content":" 1. Absolute Maximum: 50% (MAX_SAFE_FLEX)â€‹  Enforcement: core.py caps abs(flex) at 0.50 (50%)  Rationale:  Above 50%, period detection becomes unreliableBest Price: Almost entire day qualifies (Min + 50% typically covers 60-80% of intervals)Peak Price: Similar issue with Max - 50%Result: Either massive periods (entire day) or no periods (min_length not met)  Warning Message:  Flex XX% exceeds maximum safe value! Capping at 50%. Recommendation: Use 15-20% with relaxation enabled, or 25-35% without relaxation.   2. Outlier Filtering Maximum: 25%â€‹  Enforcement: core.py caps outlier filtering flex at 0.25 (25%)  Rationale:  Outlier filtering uses Flex to determine &quot;stable context&quot; thresholdAt &gt; 25% Flex, almost any price swing is considered &quot;stable&quot;Result: Legitimate price shifts aren't smoothed, breaking period formation  Note: User's Flex still applies to period criteria (in_flex check), only outlier filtering is capped.  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Recommended Ranges (User Guidance)â€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#recommended-ranges-user-guidance","content":" With Relaxation Enabled (Recommended)â€‹  Optimal: 10-20%  Relaxation increases Flex incrementally: 15% â†’ 18% â†’ 21% â†’ ...Low baseline ensures relaxation has room to work  Warning Threshold: &gt; 25%  INFO log: &quot;Base flex is on the high side&quot;  High Warning: &gt; 30%  WARNING log: &quot;Base flex is very high for relaxation mode!&quot;Recommendation: Lower to 15-20%  Without Relaxationâ€‹  Optimal: 20-35%  No automatic adjustment, must be sufficient from startHigher baseline acceptable since no relaxation fallback  Maximum Useful: ~50%  Above this, period detection degrades (see Hard Limits)    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Relaxation Strategyâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#relaxation-strategy","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Purposeâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#purpose","content":" Ensure minimum periods per day are found even when baseline filters are too strict.  Use Case: User configures strict filters (low Flex, restrictive Level) but wants guarantee of N periods/day for automation reliability.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Multi-Phase Approachâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#multi-phase-approach","content":" Each day processed independently:  Calculate baseline periods with user's configIf insufficient periods found, enter relaxation loopTry progressively relaxed filter combinationsStop when target reached or all attempts exhausted  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Relaxation Incrementsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#relaxation-increments","content":" Current Implementation (November 2025):  File: coordinator/period_handlers/relaxation.py  # Hard-coded 3% increment per step (reliability over configurability) flex_increment = 0.03 # 3% per step base_flex = abs(config.flex) # Generate flex levels for attempt in range(max_relaxation_attempts): flex_level = base_flex + (attempt Ã— flex_increment) # Try flex_level with both filter combinations   Constants:  FLEX_WARNING_THRESHOLD_RELAXATION = 0.25 # 25% - INFO: suggest lowering to 15-20% FLEX_HIGH_THRESHOLD_RELAXATION = 0.30 # 30% - WARNING: very high for relaxation mode MAX_FLEX_HARD_LIMIT = 0.50 # 50% - absolute maximum (enforced in core.py)   Design Decisions:  Why 3% fixed increment? Predictable escalation path (15% â†’ 18% â†’ 21% â†’ ...)Independent of base flex (works consistently)11 attempts covers full useful range (15% â†’ 48%)Balance: Not too slow (2%), not too fast (5%) Why hard-coded, not configurable? Prevents user misconfigurationSimplifies mental model (fewer knobs to turn)Reliable behavior across all configurationsIf needed, user adjusts max_relaxation_attempts (fewer/more steps) Why warn at 25% base flex? At 25% base, first relaxation step reaches 28%Above 30%, entering diminishing returns territoryUser likely doesn't need relaxation with such high base flexShould either: (a) lower base flex, or (b) disable relaxation  Historical Context (Pre-November 2025):  The algorithm previously used percentage-based increments that scaled with base flex:  increment = base_flex Ã— (step_pct / 100) # REMOVED   This caused exponential escalation with high base flex values (e.g., 40% â†’ 50% â†’ 60% â†’ 70% in just 6 steps), making behavior unpredictable. The fixed 3% increment solves this by providing consistent, controlled escalation regardless of starting point.  Warning Messages:  if base_flex &gt;= FLEX_HIGH_THRESHOLD_RELAXATION: # 30% _LOGGER.warning( &quot;Base flex %.1f%% is very high for relaxation mode! &quot; &quot;Consider lowering to 15-20%% or disabling relaxation.&quot;, base_flex Ã— 100, ) elif base_flex &gt;= FLEX_WARNING_THRESHOLD_RELAXATION: # 25% _LOGGER.info( &quot;Base flex %.1f%% is on the high side. &quot; &quot;Consider 15-20%% for optimal relaxation effectiveness.&quot;, base_flex Ã— 100, )   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Filter Combination Strategyâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#filter-combination-strategy","content":" Per Flex level, try in order:  Original Level filterLevel filter = &quot;any&quot; (disabled)  Early Exit: Stop immediately when target reached (don't try unnecessary combinations)  Example Flow (target=2 periods/day):  Day 2025-11-19: 1. Baseline flex=15%: Found 1 period (need 2) 2. Flex=18% + level=cheap: Found 1 period 3. Flex=18% + level=any: Found 2 periods â†’ SUCCESS (stop)     ","version":"Next ğŸš§","tagName":"h3"},{"title":"Implementation Notesâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#implementation-notes","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Key Files and Functionsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#key-files-and-functions","content":" Period Calculation Entry Point:  # coordinator/period_handlers/core.py def calculate_periods( all_prices: list[dict], config: PeriodConfig, time: TimeService, ) -&gt; dict[str, Any]   Flex + Distance Filtering:  # coordinator/period_handlers/level_filtering.py def check_interval_criteria( price: float, criteria: IntervalCriteria, ) -&gt; tuple[bool, bool] # (in_flex, meets_min_distance)   Relaxation Orchestration:  # coordinator/period_handlers/relaxation.py def calculate_periods_with_relaxation(...) -&gt; tuple[dict, dict] def relax_single_day(...) -&gt; tuple[dict, dict]   Outlier Filtering Implementationâ€‹  File: coordinator/period_handlers/outlier_filtering.py  Purpose: Detect and smooth isolated price spikes before period identification to prevent artificial fragmentation.  Algorithm Details:  Linear Regression Prediction: Uses surrounding intervals to predict expected priceWindow size: 3+ intervals (MIN_CONTEXT_SIZE)Calculates trend slope and standard deviationFormula: predicted = mean + slope Ã— (position - center) Confidence Intervals: 95% confidence level (2 standard deviations)Tolerance = 2.0 Ã— std_dev (CONFIDENCE_LEVEL constant)Outlier if: |actual - predicted| &gt; toleranceAccounts for natural price volatility in context window Symmetry Check: Rejects asymmetric outliers (threshold: 1.5 std dev)Preserves legitimate price shifts (morning/evening peaks)Algorithm: residual = abs(actual - predicted) symmetry_threshold = 1.5 Ã— std_dev if residual &gt; tolerance: # Check if spike is symmetric in context context_residuals = [abs(p - pred) for p, pred in context] avg_context_residual = mean(context_residuals) if residual &gt; symmetry_threshold Ã— avg_context_residual: # Asymmetric spike â†’ smooth it else: # Symmetric (part of trend) â†’ keep it Enhanced Zigzag Detection: Detects spike clusters via relative volatilityThreshold: 2.0Ã— local volatility (RELATIVE_VOLATILITY_THRESHOLD)Single-pass algorithm (no iteration needed)Catches patterns like: 18, 35, 19, 34, 18 (alternating spikes)  Constants:  # coordinator/period_handlers/outlier_filtering.py CONFIDENCE_LEVEL = 2.0 # 95% confidence (2 std deviations) SYMMETRY_THRESHOLD = 1.5 # Asymmetry detection threshold RELATIVE_VOLATILITY_THRESHOLD = 2.0 # Zigzag spike detection MIN_CONTEXT_SIZE = 3 # Minimum intervals for regression   Data Integrity:  Original prices stored in _original_price fieldAll statistics (daily min/max/avg) use original pricesSmoothing only affects period formation logicSmart counting: Only counts smoothing that changed period outcome  Performance:  Single pass through price dataO(n) complexity with small context windowNo iterative refinement neededTypical processing time: &lt;1ms for 96 intervals  Example Debug Output:  DEBUG: [2025-11-11T14:30:00+01:00] Outlier detected: 35.2 ct DEBUG: Context: 18.5, 19.1, 19.3, 19.8, 20.2 ct DEBUG: Residual: 14.5 ct &gt; tolerance: 4.8 ct (2Ã—2.4 std dev) DEBUG: Trend slope: 0.3 ct/interval (gradual increase) DEBUG: Predicted: 20.7 ct (linear regression) DEBUG: Smoothed to: 20.7 ct DEBUG: Asymmetry ratio: 3.2 (&gt;1.5 threshold) â†’ confirmed outlier   Why This Approach?  Linear regression over moving average: Accounts for price trends (morning ramp-up, evening decline)Moving average can't predict direction, only levelBetter accuracy on non-stationary price curves Symmetry check over fixed threshold: Prevents false positives on legitimate price shiftsAdapts to local volatility patternsPreserves user expectation: &quot;expensive during peak hours&quot; Single-pass over iterative: Predictable behavior (no convergence issues)Fast and deterministicEasier to debug and reason about  Alternative Approaches Considered:  Median filtering - Rejected: Too aggressive, removes legitimate peaksMoving average - Rejected: Can't handle trendsIQR (Interquartile Range) - Rejected: Assumes normal distributionRANSAC - Rejected: Overkill for 1D data, slow    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Debugging Tipsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#debugging-tips","content":" Enable DEBUG logging:  # configuration.yaml logger: default: info logs: custom_components.tibber_prices.coordinator.period_handlers: debug   Key log messages to watch:  &quot;Filter statistics: X intervals checked&quot; - Shows how many intervals filtered by each criterion&quot;After build_periods: X raw periods found&quot; - Periods before min_length filtering&quot;Day X: Success with flex=Y%&quot; - Relaxation succeeded&quot;High flex X% detected: Reducing min_distance Y% â†’ Z%&quot; - Distance scaling active    ","version":"Next ğŸš§","tagName":"h2"},{"title":"Common Configuration Pitfallsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#common-configuration-pitfalls","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"âŒ Anti-Pattern 1: High Flex with Relaxationâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#-anti-pattern-1-high-flex-with-relaxation","content":" Configuration:  best_price_flex: 40 enable_relaxation_best: true   Problem:  Base Flex 40% already very permissiveRelaxation increments further (43%, 46%, 49%, ...)Quickly approaches 50% cap with diminishing returns  Solution:  best_price_flex: 15 # Let relaxation increase it enable_relaxation_best: true   ","version":"Next ğŸš§","tagName":"h3"},{"title":"âŒ Anti-Pattern 2: Zero Min_Distanceâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#-anti-pattern-2-zero-min_distance","content":" Configuration:  best_price_min_distance_from_avg: 0   Problem:  &quot;Flat days&quot; (little price variation) accept all intervalsPeriods lose semantic meaning (&quot;significantly cheap&quot;)May create periods during barely-below-average times  Solution:  best_price_min_distance_from_avg: 5 # Use default 5%   ","version":"Next ğŸš§","tagName":"h3"},{"title":"âŒ Anti-Pattern 3: Conflicting Flex + Distanceâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#-anti-pattern-3-conflicting-flex--distance","content":" Configuration:  best_price_flex: 45 best_price_min_distance_from_avg: 10   Problem:  Distance filter dominates, making Flex irrelevantDynamic scaling helps but still suboptimal  Solution:  best_price_flex: 20 best_price_min_distance_from_avg: 5     ","version":"Next ğŸš§","tagName":"h3"},{"title":"Testing Scenariosâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#testing-scenarios","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Scenario 1: Normal Day (Good Variation)â€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#scenario-1-normal-day-good-variation","content":" Price Range: 10 - 20 ct/kWh (100% variation)Average: 15 ct/kWh  Expected Behavior:  Flex 15%: Should find 2-4 clear best price periodsFlex 30%: Should find 4-8 periods (more lenient)Min_Distance 5%: Effective throughout range  Debug Checks:  DEBUG: Filter statistics: 96 intervals checked DEBUG: Filtered by FLEX: 12/96 (12.5%) â† Low percentage = good variation DEBUG: Filtered by MIN_DISTANCE: 8/96 (8.3%) â† Both filters active DEBUG: After build_periods: 3 raw periods found   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Scenario 2: Flat Day (Poor Variation)â€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#scenario-2-flat-day-poor-variation","content":" Price Range: 14 - 16 ct/kWh (14% variation)Average: 15 ct/kWh  Expected Behavior:  Flex 15%: May find 1-2 small periods (or zero if no clear winners)Min_Distance 5%: Critical here - ensures only truly cheaper intervals qualifyWithout Min_Distance: Would accept almost entire day as &quot;best price&quot;  Debug Checks:  DEBUG: Filter statistics: 96 intervals checked DEBUG: Filtered by FLEX: 45/96 (46.9%) â† High percentage = poor variation DEBUG: Filtered by MIN_DISTANCE: 52/96 (54.2%) â† Distance filter dominant DEBUG: After build_periods: 1 raw period found DEBUG: Day 2025-11-11: Baseline insufficient (1 &lt; 2), starting relaxation   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Scenario 3: Extreme Day (High Volatility)â€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#scenario-3-extreme-day-high-volatility","content":" Price Range: 5 - 40 ct/kWh (700% variation)Average: 18 ct/kWh  Expected Behavior:  Flex 15%: Finds multiple very cheap periods (5-6 ct)Outlier filtering: May smooth isolated spikes (30-40 ct)Distance filter: Less impactful (clear separation between cheap/expensive)  Debug Checks:  DEBUG: Outlier detected: 38.5 ct (threshold: 4.2 ct) DEBUG: Smoothed to: 20.1 ct (trend prediction) DEBUG: Filter statistics: 96 intervals checked DEBUG: Filtered by FLEX: 8/96 (8.3%) â† Very selective DEBUG: Filtered by MIN_DISTANCE: 4/96 (4.2%) â† Flex dominates DEBUG: After build_periods: 4 raw periods found   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Scenario 4: Relaxation Successâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#scenario-4-relaxation-success","content":" Initial State: Baseline finds 1 period, target is 2  Expected Flow:  INFO: Calculating BEST PRICE periods: relaxation=ON, target=2/day, flex=15.0% DEBUG: Day 2025-11-11: Baseline found 1 period (need 2) DEBUG: Phase 1: flex 18.0% + original filters DEBUG: Found 1 period (insufficient) DEBUG: Phase 2: flex 18.0% + level=any DEBUG: Found 2 periods â†’ SUCCESS INFO: Day 2025-11-11: Success after 1 relaxation phase (2 periods)   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Scenario 5: Relaxation Exhaustedâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#scenario-5-relaxation-exhausted","content":" Initial State: Strict filters, very flat day  Expected Flow:  INFO: Calculating BEST PRICE periods: relaxation=ON, target=2/day, flex=15.0% DEBUG: Day 2025-11-11: Baseline found 0 periods (need 2) DEBUG: Phase 1-11: flex 15%â†’48%, all filter combinations tried WARNING: Day 2025-11-11: All relaxation phases exhausted, still only 1 period found INFO: Period calculation completed: 1/2 days reached target   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Debugging Checklistâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#debugging-checklist","content":" When debugging period calculation issues:  Check Filter Statistics Which filter blocks most intervals? (flex, distance, or level)High flex filtering (&gt;30%) = Need more flexibility or relaxationHigh distance filtering (&gt;50%) = Min_distance too strict or flat dayHigh level filtering = Level filter too restrictive Check Relaxation Behavior Did relaxation activate? Check for &quot;Baseline insufficient&quot; messageWhich phase succeeded? Early success (phase 1-3) = good configLate success (phase 8-11) = Consider adjusting base configExhausted all phases = Unrealistic target for this day's price curve Check Flex Warnings INFO at 25% base flex = On the high sideWARNING at 30% base flex = Too high for relaxationIf seeing these: Lower base flex to 15-20% Check Min_Distance Scaling Debug messages show &quot;High flex X% detected: Reducing min_distance Y% â†’ Z%&quot;If scale factor &lt;0.8 (20% reduction): High flex is activeIf periods still not found: Filters conflict even with scaling Check Outlier Filtering Look for &quot;Outlier detected&quot; messagesCheck period_interval_smoothed_count attributeIf no smoothing but periods fragmented: Not isolated spikes, but legitimate price levels    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Future Enhancementsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#future-enhancements","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Potential Improvementsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#potential-improvements","content":" Adaptive Flex Calculation: Auto-adjust Flex based on daily price variationHigh variation days: Lower Flex neededLow variation days: Higher Flex needed Machine Learning Approach: Learn optimal Flex/Distance from user feedbackClassify days by pattern (normal/flat/volatile/bimodal)Apply pattern-specific defaults Multi-Objective Optimization: Balance period count vs. qualityConsider period duration vs. price levelOptimize for user's stated use case (EV charging vs. heat pump)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Known Limitationsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#known-limitations","content":" Fixed increment step: 3% cap may be too aggressive for very low base FlexLinear distance scaling: Could benefit from non-linear curveNo consideration of temporal distribution: May find all periods in one part of day    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Future Enhancementsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#future-enhancements-1","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Potential Improvementsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#potential-improvements-1","content":" 1. Adaptive Flex Calculation (Not Yet Implemented)â€‹  Concept: Auto-adjust Flex based on daily price variation  Algorithm:  # Pseudo-code for adaptive flex variation = (daily_max - daily_min) / daily_avg if variation &lt; 0.15: # Flat day (&lt; 15% variation) adaptive_flex = 0.30 # Need higher flex elif variation &gt; 0.50: # High volatility (&gt; 50% variation) adaptive_flex = 0.10 # Lower flex sufficient else: # Normal day adaptive_flex = 0.15 # Standard flex   Benefits:  Eliminates need for relaxation on most daysSelf-adjusting to market conditionsBetter user experience (less configuration needed)  Challenges:  Harder to predict behavior (less transparent)May conflict with user's mental modelNeeds extensive testing across different markets  Status: Considered but not implemented (prefer explicit relaxation)  2. Machine Learning Approach (Future Work)â€‹  Concept: Learn optimal Flex/Distance from user feedback  Approach:  Track which periods user actually uses (automation triggers)Classify days by pattern (normal/flat/volatile/bimodal)Apply pattern-specific defaultsLearn per-user preferences over time  Benefits:  Personalized to user's actual behaviorAdapts to local market patternsCould discover non-obvious patterns  Challenges:  Requires user feedback mechanism (not implemented)Privacy concerns (storing usage patterns)Complexity for users to understand &quot;why this period?&quot;Cold start problem (new users have no history)  Status: Theoretical only (no implementation planned)  3. Multi-Objective Optimization (Research Idea)â€‹  Concept: Balance multiple goals simultaneously  Goals:  Period count vs. quality (cheap vs. very cheap)Period duration vs. price level (long mediocre vs. short excellent)Temporal distribution (spread throughout day vs. clustered)User's stated use case (EV charging vs. heat pump vs. dishwasher)  Algorithm:  Pareto optimization (find trade-off frontier)User chooses point on frontier via preferencesGenetic algorithm or simulated annealing  Benefits:  More sophisticated period selectionBetter match to user's actual needsCould handle complex appliance requirements  Challenges:  Much more complex to implementHarder to explain to usersComputational cost (may need caching)Configuration explosion (too many knobs)  Status: Research idea only (not planned)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Known Limitationsâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#known-limitations-1","content":" 1. Fixed Increment Stepâ€‹  Current: 3% cap may be too aggressive for very low base Flex  Example:  Base flex 5% + 3% increment = 8% (60% increase!)Base flex 15% + 3% increment = 18% (20% increase)  Possible Solution:  Percentage-based increment: increment = max(base_flex Ã— 0.20, 0.03)This gives: 5% â†’ 6% (20%), 15% â†’ 18% (20%), 40% â†’ 43% (7.5%)  Why Not Implemented:  Very low base flex (&lt;10%) unusualUsers with strict requirements likely disable relaxationSimplicity preferred over edge case optimization  2. Linear Distance Scalingâ€‹  Current: Linear scaling may be too aggressive/conservative  Alternative: Non-linear curve  # Example: Exponential scaling scale_factor = 0.25 + 0.75 Ã— exp(-5 Ã— (flex - 0.20)) # Or: Sigmoid scaling scale_factor = 0.25 + 0.75 / (1 + exp(10 Ã— (flex - 0.35)))   Why Not Implemented:  Linear is easier to reason aboutNo evidence that non-linear is betterWould need extensive testing  3. No Temporal Distribution Considerationâ€‹  Issue: May find all periods in one part of day  Example:  All 3 &quot;best price&quot; periods between 02:00-08:00No periods in evening (when user might want to run appliances)  Possible Solution:  Add &quot;spread&quot; parameter (prefer distributed periods)Weight periods by time-of-day preferencesConsider user's typical usage patterns  Why Not Implemented:  Adds complexityUsers can work around with multiple automationsDifferent users have different needs (no one-size-fits-all)  4. Period Boundary Handlingâ€‹  Current Behavior: Periods can cross midnight naturally  Design Principle: Each interval is evaluated using its own day's reference prices (daily min/max/avg).  Implementation:  # In period_building.py build_periods(): for price_data in all_prices: starts_at = time.get_interval_time(price_data) date_key = starts_at.date() # CRITICAL: Use interval's own day, not period_start_date ref_date = date_key criteria = TibberPricesIntervalCriteria( ref_price=ref_prices[ref_date], # Interval's day avg_price=avg_prices[ref_date], # Interval's day flex=flex, min_distance_from_avg=min_distance_from_avg, reverse_sort=reverse_sort, )   Why Per-Day Evaluation?  Periods can cross midnight (e.g., 23:45 â†’ 01:00). Each day has independent reference prices calculated from its 96 intervals.  Example showing the problem with period-start-day approach:  Day 1 (2025-11-21): Cheap day daily_min = 10 ct, daily_avg = 20 ct, flex = 15% Criteria: price â‰¤ 11.5 ct (10 + 10Ã—0.15) Day 2 (2025-11-22): Expensive day daily_min = 20 ct, daily_avg = 30 ct, flex = 15% Criteria: price â‰¤ 23 ct (20 + 20Ã—0.15) Period crossing midnight: 23:45 Day 1 â†’ 00:15 Day 2 23:45 (Day 1): 11 ct â†’ âœ… Passes (11 â‰¤ 11.5) 00:00 (Day 2): 21 ct â†’ Should this pass? âŒ WRONG (using period start day): 00:00 evaluated against Day 1's 11.5 ct threshold 21 ct &gt; 11.5 ct â†’ Fails But 21ct IS cheap on Day 2 (min=20ct)! âœ… CORRECT (using interval's own day): 00:00 evaluated against Day 2's 23 ct threshold 21 ct â‰¤ 23 ct â†’ Passes Correctly identified as cheap relative to Day 2   Trade-off: Periods May Break at Midnight  When days differ significantly, period can split:  Day 1: Min=10ct, Avg=20ct, 23:45=11ct â†’ âœ… Cheap (relative to Day 1) Day 2: Min=25ct, Avg=35ct, 00:00=21ct â†’ âŒ Expensive (relative to Day 2) Result: Period stops at 23:45, new period starts later   This is mathematically correct - 21ct is genuinely expensive on a day where minimum is 25ct.  Market Reality Explains Price Jumps:  Day-ahead electricity markets (EPEX SPOT) set prices at 12:00 CET for all next-day hours:  Late intervals (23:45): Priced ~36h before delivery â†’ high forecast uncertainty â†’ risk premiumEarly intervals (00:00): Priced ~12h before delivery â†’ better forecasts â†’ lower risk buffer  This explains why absolute prices jump at midnight despite minimal demand changes.  User-Facing Solution (Nov 2025):  Added per-period day volatility attributes to detect when classification changes are meaningful:  day_volatility_%: Percentage spread (span/avg Ã— 100)day_price_min, day_price_max, day_price_span: Daily price range (ct/Ã¸re)  Automations can check volatility before acting:  condition: - condition: template value_template: &gt; {{ state_attr('binary_sensor.tibber_home_best_price_period', 'day_volatility_%') | float(0) &gt; 15 }}   Low volatility (&lt; 15%) means classification changes are less economically significant.  Alternative Approaches Rejected:  Use period start day for all intervals Problem: Mathematically incorrect - lends cheap day's criteria to expensive dayRejected: Violates relative evaluation principle Adjust flex/distance at midnight Problem: Complex, unpredictable, hides market realityRejected: Users should understand price context, not have it hidden Split at midnight always Problem: Artificially fragments natural periodsRejected: Worse user experience Use next day's reference after midnight Problem: Period criteria inconsistent across durationRejected: Confusing and unpredictable  Status: Per-day evaluation is intentional design prioritizing mathematical correctness.  See Also:  User documentation: docs/user/period-calculation.md â†’ &quot;Midnight Price Classification Changes&quot;Implementation: coordinator/period_handlers/period_building.py (line ~126: ref_date = date_key)Attributes: coordinator/period_handlers/period_statistics.py (day volatility calculation)    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Referencesâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#references","content":" User Documentation: Period CalculationArchitecture OverviewCaching StrategyAGENTS.md - AI assistant memory (implementation patterns)  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Changelogâ€‹","type":1,"pageTitle":"Period Calculation Theory","url":"/hass.tibber_prices/developer/period-calculation-theory#changelog","content":" 2025-11-19: Initial documentation of Flex/Distance interaction and Relaxation strategy fixes ","version":"Next ğŸš§","tagName":"h2"},{"title":"Timer Architecture","type":0,"sectionRef":"#","url":"/hass.tibber_prices/developer/timer-architecture","content":"","keywords":"","version":"Next ğŸš§"},{"title":"Overviewâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#overview","content":" The integration uses three independent timer mechanisms for different purposes:  Timer\tType\tInterval\tPurpose\tTrigger MethodTimer #1\tHA built-in\t15 minutes\tAPI data updates\tDataUpdateCoordinator Timer #2\tCustom\t:00, :15, :30, :45\tEntity state refresh\tasync_track_utc_time_change() Timer #3\tCustom\tEvery minute\tCountdown/progress\tasync_track_utc_time_change()  Key principle: Timer #1 (HA) controls data fetching, Timer #2 controls entity updates, Timer #3 controls timing displays.    ","version":"Next ğŸš§","tagName":"h2"},{"title":"Timer #1: DataUpdateCoordinator (HA Built-in)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#timer-1-dataupdatecoordinator-ha-built-in","content":" File: coordinator/core.py â†’ TibberPricesDataUpdateCoordinator  Type: Home Assistant's built-in DataUpdateCoordinator with UPDATE_INTERVAL = 15 minutes  What it is:  HA provides this timer system automatically when you inherit from DataUpdateCoordinatorTriggers _async_update_data() method every 15 minutesNot synchronized to clock boundaries (each installation has different start time)  Purpose: Check if fresh API data is needed, fetch if necessary  What it does:  async def _async_update_data(self) -&gt; TibberPricesData: # Step 1: Check midnight turnover FIRST (prevents race with Timer #2) if self._check_midnight_turnover_needed(dt_util.now()): await self._perform_midnight_data_rotation(dt_util.now()) # Notify ALL entities after midnight turnover return self.data # Early return # Step 2: Check if we need tomorrow data (after 13:00) if self._should_update_price_data() == &quot;tomorrow_check&quot;: await self._fetch_and_update_data() # Fetch from API return self.data # Step 3: Use cached data (fast path - most common) return self.data   Load Distribution:  Each HA installation starts Timer #1 at different times â†’ natural distributionTomorrow data check adds 0-30s random delay â†’ prevents &quot;thundering herd&quot; on Tibber APIResult: API load spread over ~30 minutes instead of all at once  Midnight Coordination:  Atomic check: _check_midnight_turnover_needed(now) compares dates only (no side effects)If midnight turnover needed â†’ performs it and returns earlyTimer #2 will see turnover already done and skip gracefully  Why we use HA's timer:  Automatic restart after HA restartBuilt-in retry logic for temporary failuresStandard HA integration patternHandles backpressure (won't queue up if previous update still running)    ","version":"Next ğŸš§","tagName":"h2"},{"title":"Timer #2: Quarter-Hour Refresh (Custom)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#timer-2-quarter-hour-refresh-custom","content":" File: coordinator/listeners.py â†’ ListenerManager.schedule_quarter_hour_refresh()  Type: Custom timer using async_track_utc_time_change(minute=[0, 15, 30, 45], second=0)  Purpose: Update time-sensitive entity states at interval boundaries without waiting for API poll  Problem it solves:  Timer #1 runs every 15 minutes but NOT synchronized to clock (:03, :18, :33, :48)Current price changes at :00, :15, :30, :45 â†’ entities would show stale data for up to 15 minutesExample: 14:00 new price, but Timer #1 ran at 13:58 â†’ next update at 14:13 â†’ users see old price until 14:13  What it does:  async def _handle_quarter_hour_refresh(self, now: datetime) -&gt; None: # Step 1: Check midnight turnover (coordinates with Timer #1) if self._check_midnight_turnover_needed(now): # Timer #1 might have already done this â†’ atomic check handles it await self._perform_midnight_data_rotation(now) # Notify ALL entities after midnight turnover return # Step 2: Normal quarter-hour refresh (most common path) # Only notify time-sensitive entities (current_interval_price, etc.) self._listener_manager.async_update_time_sensitive_listeners()   Smart Boundary Tolerance:  Uses round_to_nearest_quarter_hour() with Â±2 second toleranceHA may schedule timer at 14:59:58 â†’ rounds to 15:00:00 (shows new interval)HA restart at 14:59:30 â†’ stays at 14:45:00 (shows current interval)See Architecture for details  Absolute Time Scheduling:  async_track_utc_time_change() plans for all future boundaries (15:00, 15:15, 15:30, ...)NOT relative delays (&quot;in 15 minutes&quot;)If triggered at 14:59:58 â†’ next trigger is 15:15:00, NOT 15:00:00 (prevents double updates)  Which entities listen:  All sensors that depend on &quot;current interval&quot; (e.g., current_interval_price, next_interval_price)Binary sensors that check &quot;is now in period?&quot; (e.g., best_price_period_active)~50-60 entities out of 120+ total  Why custom timer:  HA's built-in coordinator doesn't support exact boundary timingWe need absolute time triggers, not periodic intervalsAllows fast entity updates without expensive data transformation    ","version":"Next ğŸš§","tagName":"h2"},{"title":"Timer #3: Minute Refresh (Custom)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#timer-3-minute-refresh-custom","content":" File: coordinator/listeners.py â†’ ListenerManager.schedule_minute_refresh()  Type: Custom timer using async_track_utc_time_change(second=0) (every minute)  Purpose: Update countdown and progress sensors for smooth UX  What it does:  async def _handle_minute_refresh(self, now: datetime) -&gt; None: # Only notify minute-update entities # No data fetching, no transformation, no midnight handling self._listener_manager.async_update_minute_listeners()   Which entities listen:  best_price_remaining_minutes - Countdown timerpeak_price_remaining_minutes - Countdown timerbest_price_progress - Progress bar (0-100%)peak_price_progress - Progress bar (0-100%)~10 entities total  Why custom timer:  Users want smooth countdowns (not jumping 15 minutes at a time)Progress bars need minute-by-minute updatesVery lightweight (no data processing, just state recalculation)  Why NOT every second:  Minute precision sufficient for countdown UXReduces CPU load (60Ã— fewer updates than seconds)Home Assistant best practice (avoid sub-minute updates)    ","version":"Next ğŸš§","tagName":"h2"},{"title":"Listener Pattern (Python/HA Terminology)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#listener-pattern-pythonha-terminology","content":" Your question: &quot;Sind Timer fÃ¼r dich eigentlich 'Listener'?&quot;  Answer: In Home Assistant terminology:  Timer = The mechanism that triggers at specific times (async_track_utc_time_change)Listener = A callback function that gets called when timer triggersObserver Pattern = Entities register callbacks, coordinator notifies them  How it works:  # Entity registers a listener callback class TibberPricesSensor(CoordinatorEntity): async def async_added_to_hass(self): # Register this entity's update callback self._remove_listener = self.coordinator.async_add_time_sensitive_listener( self._handle_coordinator_update ) # Coordinator maintains list of listeners class ListenerManager: def __init__(self): self._time_sensitive_listeners = [] # List of callbacks def async_add_time_sensitive_listener(self, callback): self._time_sensitive_listeners.append(callback) def async_update_time_sensitive_listeners(self): # Timer triggered â†’ notify all listeners for callback in self._time_sensitive_listeners: callback() # Entity updates itself   Why this pattern:  Decouples timer logic from entity logicOne timer can notify many entities efficientlyEntities can unregister when removed (cleanup)Standard HA pattern for coordinator-based integrations    ","version":"Next ğŸš§","tagName":"h2"},{"title":"Timer Coordination Scenariosâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#timer-coordination-scenarios","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Scenario 1: Normal Operation (No Midnight)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#scenario-1-normal-operation-no-midnight","content":" 14:00:00 â†’ Timer #2 triggers â†’ Update time-sensitive entities (current price changed) â†’ 60 entities updated (~5ms) 14:03:12 â†’ Timer #1 triggers (HA's 15-min cycle) â†’ Check if tomorrow data needed (no, still cached) â†’ Return cached data (fast path, ~2ms) 14:15:00 â†’ Timer #2 triggers â†’ Update time-sensitive entities â†’ 60 entities updated (~5ms) 14:16:00 â†’ Timer #3 triggers â†’ Update countdown/progress entities â†’ 10 entities updated (~1ms)   Key observation: Timer #1 and Timer #2 run independently, no conflicts.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Scenario 2: Midnight Turnoverâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#scenario-2-midnight-turnover","content":" 23:45:12 â†’ Timer #1 triggers â†’ Check midnight: current_date=2025-11-17, last_check=2025-11-17 â†’ No turnover needed â†’ Return cached data 00:00:00 â†’ Timer #2 triggers FIRST (synchronized to midnight) â†’ Check midnight: current_date=2025-11-18, last_check=2025-11-17 â†’ Turnover needed! Perform rotation, save cache â†’ _last_midnight_check = 2025-11-18 â†’ Notify ALL entities 00:03:12 â†’ Timer #1 triggers (its regular cycle) â†’ Check midnight: current_date=2025-11-18, last_check=2025-11-18 â†’ Turnover already done â†’ skip â†’ Return existing data (fast path)   Key observation: Atomic date comparison prevents double-turnover, whoever runs first wins.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Scenario 3: Tomorrow Data Check (After 13:00)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#scenario-3-tomorrow-data-check-after-1300","content":" 13:00:00 â†’ Timer #2 triggers â†’ Normal quarter-hour refresh â†’ Update time-sensitive entities 13:03:12 â†’ Timer #1 triggers â†’ Check tomorrow data: missing or invalid â†’ Fetch from Tibber API (~300ms) â†’ Transform data (~200ms) â†’ Calculate periods (~100ms) â†’ Notify ALL entities (new data available) 13:15:00 â†’ Timer #2 triggers â†’ Normal quarter-hour refresh (uses newly fetched data) â†’ Update time-sensitive entities   Key observation: Timer #1 does expensive work (API + transform), Timer #2 does cheap work (entity notify).    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Why We Keep HA's Timer (Timer #1)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#why-we-keep-has-timer-timer-1","content":" Your question: &quot;warum wir den HA timer trotzdem weiter benutzen, da er ja fÃ¼r uns unkontrollierte aktualisierte Ã¤nderungen triggert&quot;  Answer: You're correct that it's not synchronized, but that's actually intentional:  ","version":"Next ğŸš§","tagName":"h2"},{"title":"Reason 1: Load Distribution on Tibber APIâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#reason-1-load-distribution-on-tibber-api","content":" If all installations used synchronized timers:  âŒ Everyone fetches at 13:00:00 â†’ Tibber API overloadâŒ Everyone fetches at 14:00:00 â†’ Tibber API overloadâŒ &quot;Thundering herd&quot; problem  With HA's unsynchronized timer:  âœ… Installation A: 13:03:12, 13:18:12, 13:33:12, ...âœ… Installation B: 13:07:45, 13:22:45, 13:37:45, ...âœ… Installation C: 13:11:28, 13:26:28, 13:41:28, ...âœ… Natural distribution over ~30 minutesâœ… Plus: Random 0-30s delay on tomorrow checks  Result: API load spread evenly, no spikes.  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Reason 2: What Timer #1 Actually Checksâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#reason-2-what-timer-1-actually-checks","content":" Timer #1 does NOT blindly update. It checks:  def _should_update_price_data(self) -&gt; str: # Check 1: Do we have tomorrow data? (only relevant after ~13:00) if tomorrow_missing or tomorrow_invalid: return &quot;tomorrow_check&quot; # Fetch needed # Check 2: Is cache still valid? if cache_valid: return &quot;cached&quot; # No fetch needed (most common!) # Check 3: Has enough time passed? if time_since_last_update &lt; threshold: return &quot;cached&quot; # Too soon, skip fetch return &quot;update_needed&quot; # Rare case   Most Timer #1 cycles: Fast path (~2ms), no API call, just returns cached data.  API fetch only when:  Tomorrow data missing/invalid (after 13:00)Cache expired (midnight turnover)Explicit user refresh  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Reason 3: HA Integration Best Practicesâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#reason-3-ha-integration-best-practices","content":" âœ… Standard HA pattern: DataUpdateCoordinator is recommended by HA docsâœ… Automatic retry logic for temporary API failuresâœ… Backpressure handling (won't queue updates if previous still running)âœ… Developer tools integration (users can manually trigger refresh)âœ… Diagnostics integration (shows last update time, success/failure)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"What We DO Synchronizeâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#what-we-do-synchronize","content":" âœ… Timer #2: Entity state updates at exact boundaries (user-visible)âœ… Timer #3: Countdown/progress at exact minutes (user-visible)âŒ Timer #1: API fetch timing (invisible to user, distribution wanted)    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Performance Characteristicsâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#performance-characteristics","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Timer #1 (DataUpdateCoordinator)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#timer-1-dataupdatecoordinator","content":" Triggers: Every 15 minutes (unsynchronized)Fast path: ~2ms (cache check, return existing data)Slow path: ~600ms (API fetch + transform + calculate)Frequency: ~96 times/dayAPI calls: ~1-2 times/day (cached otherwise)  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Timer #2 (Quarter-Hour Refresh)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#timer-2-quarter-hour-refresh","content":" Triggers: 96 times/day (exact boundaries)Processing: ~5ms (notify 60 entities)No API calls: Uses cached/transformed dataNo transformation: Just entity state updates  ","version":"Next ğŸš§","tagName":"h3"},{"title":"Timer #3 (Minute Refresh)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#timer-3-minute-refresh","content":" Triggers: 1440 times/day (every minute)Processing: ~1ms (notify 10 entities)No API calls: No data processing at allLightweight: Just countdown math  Total CPU budget: ~15 seconds/day for all timers combined.    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Debugging Timer Issuesâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#debugging-timer-issues","content":" ","version":"Next ğŸš§","tagName":"h2"},{"title":"Check Timer #1 (HA Coordinator)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#check-timer-1-ha-coordinator","content":" # Enable debug logging _LOGGER.setLevel(logging.DEBUG) # Watch for these log messages: &quot;Fetching data from API (reason: tomorrow_check)&quot; # API call &quot;Using cached data (no update needed)&quot; # Fast path &quot;Midnight turnover detected (Timer #1)&quot; # Turnover   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Check Timer #2 (Quarter-Hour)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#check-timer-2-quarter-hour","content":" # Watch coordinator logs: &quot;Updated 60 time-sensitive entities at quarter-hour boundary&quot; # Normal &quot;Midnight turnover detected (Timer #2)&quot; # Turnover   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Check Timer #3 (Minute)â€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#check-timer-3-minute","content":" # Watch coordinator logs: &quot;Updated 10 minute-update entities&quot; # Every minute   ","version":"Next ğŸš§","tagName":"h3"},{"title":"Common Issuesâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#common-issues","content":" Timer #2 not triggering: Check: schedule_quarter_hour_refresh() called in __init__?Check: _quarter_hour_timer_cancel properly stored? Double updates at midnight: Should NOT happen (atomic coordination)Check: Both timers use same date comparison logic? API overload: Check: Random delay working? (0-30s jitter on tomorrow check)Check: Cache validation logic correct?    ","version":"Next ğŸš§","tagName":"h3"},{"title":"Related Documentationâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#related-documentation","content":" Architecture - Overall system design, data flowCaching Strategy - Cache lifetimes, invalidation, midnight turnoverAGENTS.md - Complete reference for AI development    ","version":"Next ğŸš§","tagName":"h2"},{"title":"Summaryâ€‹","type":1,"pageTitle":"Timer Architecture","url":"/hass.tibber_prices/developer/timer-architecture#summary","content":" Three independent timers:  Timer #1 (HA built-in, 15 min, unsynchronized) â†’ Data fetching (when needed)Timer #2 (Custom, :00/:15/:30/:45) â†’ Entity state updates (always)Timer #3 (Custom, every minute) â†’ Countdown/progress (always)  Key insights:  Timer #1 unsynchronized = good (load distribution on API)Timer #2 synchronized = good (user sees correct data immediately)Timer #3 synchronized = good (smooth countdown UX)All three coordinate gracefully (atomic midnight checks, no conflicts)  &quot;Listener&quot; terminology:  Timer = mechanism that triggersListener = callback that gets calledObserver pattern = entities register, coordinator notifies ","version":"Next ğŸš§","tagName":"h2"}],"options":{"id":"default"}}